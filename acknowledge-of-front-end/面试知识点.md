# 一、JavaScript

## 1、闭包

1.1**理解闭包**

- 定义：当函数可以记住并访问所在的词法作用域

- 闭包本质上就是一个函数，但是他能够访问其他函数的作用域。
- 闭包最简单的实现方式就是，一个函数内部再创建一个函数，那么这个内部函数就被称为闭包。
- 这个函数持有对外部函数的一个引用，可以访问到外部函数的变量等等

1.2**闭包的特性**

- 闭包可以解决变量命名冲突问题
- 可以保护私有变量
- 但是由于闭包一直持有对外部函数的引用，所以外部函数在内存中无法被销毁，导致内存占用率比较高，如果使用不当还会造成内存泄漏

1.3**闭包的应用**

- 最简单的例子就是我们的定时器了，在函数内部开启一个定时器，如下所示

```javascript
        function fun(){
            let a=10;
            setTimeout((()=>{
                console.log(a);
            }))
        }
        fun();//10
```

- 因为定时器的回调函数持有对外部函数fun的一个引用，所以他才能右值查找得到a变量的值，就是闭包的一个简单的应用。
- 其次还有防抖和节流的封装以及模块化，都用到了闭包，以及函数的柯里化都用到了闭包。


## 2、异步加载JS的方式

3.1**同步加载**

- 同步模式又称为阻塞模式，会阻止浏览器的后续处理，停止后续的解析，只有当当前加载完成，才能进行下一步。所以默认同步执行才是安全的。
- 为什么js代码会阻塞dom的解析？因为js脚本中可能会对dom进行操作，为了保证dom的正确性，才让js先执行完，把dom操作弄完之后再解析dom，最后再渲染dom
- 同时外部css的引入不会阻塞浏览器的解析，而是会阻塞浏览器的渲染，因为外部css的引入阻塞了渲染树的生成

3.2**异步加载**

>**1、css加载不会阻塞DOM树的解析**：这两个是并行处理的
>
>**2、css加载会阻塞DOM树的渲染**：因为css样式没有加载完毕的话式没有办法合成render树的
>
>**3、css加载会阻塞后面js语句的执行**：设想JS脚本中的内容是获取DOM元素的CSS样式属性，如果JS想要获取到DOM最新的正确的样式，势必需要所有的CSS加载完成，否则获取的样式可能是错误或者不是最新的。因此要等到JS脚本前面的CSS加载完成，JS才能再执行，
>
>**4、script脚本的加载和执行都会阻塞html的解析**：这是因为js中可能会操作dom结构，首先浏览器无法知晓JS的具体内容，倘若先解析DOM，万一JS内部全部删除掉DOM，那么浏览器就白忙活了，所以就干脆暂停解析DOM，等到JS执行完成再继续解析。

- 方式1：在script标签上添加属性：defer
- 方式2：在script标签上添加属性：async，（必须是外部的js脚本）
- 方式3：动态创建script
- 三种方式均可实现异步加载js脚本，即在加载的时候和dom解析渲染并行，等加载完毕执行js脚本的时候才会阻塞

3.3**defer和async的区别**

- defer是加载完之后会按照script标签的顺序依次执行
- async是加载完成之后就立即执行，并不会按照顺序来

## 3、**DOM对象的property和attributs**

- 两者都有属性的意思，但是attribute指的是html标签本身就具有的属性，如id、class等，property就指的是标签元素作为DOM对象被附加的属性如Childern属性
- API:getAttributs可以获得所有的属性
- property属性的获取是通过对象的点语法获取
- https://blog.csdn.net/m0_37645820/article/details/78276033

## 4、ES6新特性

- let、const
- 模板字符串
- 箭头函数
- for...of...
- Promise
- 模块化编程

## 5、==和===

- ==的比较规则，如果两边的等类型不一样不同就会进行类型转换，然后在进行比较；
  - 如果两边类型相同进行===比较
  - null和undefined比较结果是true
  - 另外如果是String||Bollean和Number进行比较，那么可以理解为String和Bollean会降级为Number再和Number进行比较。
  - 如果一边是引用数据类型，另一边是基本数据类型，就将对象转为基础类型，利用它的toStirng和valueOf方法，js核心内置类中调用valueOf优先于toString，例外的是Date，Date对象利用的是toString转换
  - 如何其他组合都不想等

## 6、JS数组和对象的遍历方式

- for..of
  - 可以遍历可迭代对象比如数组，直接获得数组的值
  - 但是不可以用来遍历对象
- for..in
  - 既可以用来遍历数组，也可以用来遍历对象，遍历索引值
  - for..in将数组的原型对象以及数组对象本身属性值都会返回
  - 所以for..In 可能会返回我们并不希望获取的存在于原型对象上的属性，为了解决这个问题，可以用hasOwnProperty进行判断
- map：(function(currentValue,index,arr), thisValue)
- foreach：(function(currentValue, index, arr), thisValue)
- reduce：(function(currentValue,index,arr), thisValue)
- for循环

## 7、事件流模型

10.1**三个阶段**

- 捕获阶段（从DOM树的根节点寻找事件的触发点）
- 目标阶段：捕获到事件的触发源，尝试执行回调函数（因为可能有也可能没有）
- 冒泡阶段：从触发源沿着捕获阶段的路径原路返回

10.2事件代理

- 默认情况下，如果事件触发源的父级元素也订阅了该事件，那么在冒泡阶段就会执行这些回调
- 可以通过event.stopPropogation阻止冒泡事件
- 如果设置会捕获阶段触发，那么不过阶段也会触发对应的回调

## 8、分段渲染

- 如果所有dom等全部创建完毕在一次性扔到页面上会导致页面出现长时间的空白（也为创建dom需要一定时间）
- 这也是前端的一种优化手段，减少首屏加载时间
- 为了避免这种情况，就需要分段渲染，一次渲染一部分

```javascript
        let total = 10000;
        // 每10ms渲染20条数据
        // pageNums:总页数
        let pageNums = total/20;
        let ul = document.querySelector('ul')
        function renderLoop(curTotal,curPageNo){
            // curTotal还剩多少
            // curPageNo第几页
            if(curTotal<=0||curPageNo>pageNums)
                return;
            // 每页20条,如果最后剩下的小于20就用剩下的
            let pageSize = Math.min(curTotal,20);
            // 创建文档片段,吧li放在片段里,最后一次性 放入ul中,避免频繁重绘重排
            let fragment = document.createDocumentFragment();

            console.time('li')
            for(let i=0;i<pageSize;i++)
            {
                // 创建元素
                let li = document.createElement('li');
                // 为当前元素插入内容
                li.innerHTML = `当前页码为${curPageNo},数据为:${pageSize*(curPageNo-1)+i+1}`;
                // 插入ul
                // ul.appendChild(li);
                fragment.appendChild(li);
            }
            // 将文档片段插入ul,只需要一次重绘重排
            ul.appendChild(fragment)
            console.timeEnd('li')
            
            // 当前这次渲染循环结束了,20ms后进行下一次
            window.requestAnimationFrame(()=>{
                renderLoop(curTotal-20,curPageNo+1)
            })
        }
        setTimeout(()=>{
            renderLoop(total,1);
        })
```

## 9、async/await执行顺序

- ```javascript
          async function async1() {
              console.log("2");
              const data = await async2();
              console.log("3");
              return data;
          }
        
          async function async2() {
              return new Promise((resolve) => {
                  console.log("4");
                  resolve("async2的结果");
              }).then((data) => {
                  console.log("5");
                  return data;
              });
          }
          
          async1().then((data) => {
              console.log("6");
              console.log(data);
          });
  ```

- 第一步：执行函数async1

- 第二步：输出2

- 第三步：碰到了await，等待异步代码async2执行完成（完成指调用了resolve或者reject）

- 第四步：async2执行结束，并调用了resolve("async2的结果")，同时将then接受的回调压入微任务队列

- 第五步：将await后续的代码封装到promise.then方法里，也就是说加入了微任务队列

- 第六步：此时async1还没有执行结束，因为还有一部分在微任务队列里

- 第七步：等到async1执行结束，将其后面的then方法压入微任务队列

- 第八步：主线任务全部结束了， 清空微任务队列和宏任务队列

## 10、异步执行顺序考察

```javascript
setTimeout(function () {
  console.log("1");
}, 0);
async function async1() {
  console.log("2");
  const data = await async2();
  console.log("3");
  return data;
}
async function async2() {
  return new Promise((resolve) => {
    console.log("4");
    resolve("async2的结果");
  }).then((data) => {
    console.log("5");
    return data;
  });
}
async1().then((data) => {
  console.log("6");
  console.log(data);
});
new Promise(function (resolve) {
  console.log("7");
  //   resolve()
}).then(function () {
  console.log("8");
});

```

## 11、手写VDOM转为真实DOM

```javascript
        let body = document.querySelector('body');

        let vDom = {
            tag: 'DIV',
            attrs: {
                id: 'app'
            },
            children: [{
                    tag: 'SPAN',
                    children: [{
                        tag: 'A',
                        children: []
                    }]
                },
                {
                    tag: 'SPAN',
                    children: [{
                            tag: 'A',
                            children: []
                        },
                        {
                            tag: 'A',
                            children: []
                        }
                    ]
                }
            ]
        }


        let createEl = function (root, vNode) {
            if (!vNode)
                return;
            let tag = vNode.tag.toLowerCase();
            let tagNode = document.createElement(tag);
            if(vNode.attrs)
            {
                for(let key in vNode.attrs)
                {
                    if(vNode.attrs.hasOwnProperty(key))
                    {
                        tagNode.setAttribute(`${key}`,vNode.attrs[key]);
                    }
                }
            }
            if (vNode.children.length != 0) {
                for(let i=0;i<vNode.children.length;i++)
                {
                    createEl(tagNode,vNode.children[i])
                }
            }
            root.appendChild(tagNode);
        }

        createEl(body,vDom)
```

## 12、手写柯里化函数
```
  // 函数的柯里化？其实就是一个高阶函数，函数返回一个新的函数
  // 作用1:参数复用
   const getUriFunc = (protocal:string)=>{
      return function(hostname:string,path:string){
        console.log(`${protocal}${hostname}${path}`)
      }
   }
   const uriFunc = getUriFunc('https://')
   const uri = uriFunc('www.baidu.com','/1')
 // 作用2:浏览器兼容性处理
 ![image](https://user-images.githubusercontent.com/102949426/172034922-13c1c566-29c8-43ee-95c0-92579c02ad32.png)
 // 作用3:函数延时执行:等到参数收集完全之后再执行
 ![image](https://user-images.githubusercontent.com/102949426/172034941-da4ab307-5720-411d-ad12-d88299e0389e.png)

```

## 13、浅拷贝&&深拷贝

- 浅拷贝只拷贝第一层
- 注意：对象是放在堆内存的，对象A的属性a指向一个数组C，对象B的属性a也指向同一个数组C，如果你采用A.a=[]方式修改，你改的仅仅是对象A的属性，对B不会有任何的影响，如果采用A.a[0]=0去改，那么你改的就是数组C。对象B也会同时收到影响

```javascript
let shallClone = function(target){
    if(typeof target!='object'){
        return target
    }else{
        let res = Array.isArray(target)?[]:{};
        for(let prp in target)
        {
            if(target.hasOwnProperty(prp))
            {
                res[prp] = target[prp]
            }
        }
        return res;
    }
}
```

- 深拷贝是拷贝目标对象身上的所有值，采用递归实现

```javascript
let deepClone = function(target)
{
    let ret = null;
    if(typeof target!='object')
    {
        return target;
    }else{
        ret = Array.isArray(target)?[]:{};
        for(let prp in target){
            if(target.hasOwnProperty(prp))
            {
                ret[prp] = deepClone(target[prp])
            }
        }
    }
    return ret;
}
```

## 14、instancOf原理

- 获取当前实例对象的原型
- 判断当前类的原型prototype是否出现在该实例对象的原型链上
- 如果有返回true
- 否则返回false

```JavaScript
// instancOf机制
let _instanceOf = function(obj,Object){
    if(typeof obj != 'object')
    {
        throw new Error('请正确传入参数')
    }
    let proto = obj.__proto__;
    let classPorto = Object.prototype;
    while(proto!=null)
    {
        if(proto===classPorto)
        {
            return true;
        }else{
            proto = proto.__proto__;
        }
    }
    return false
}
```

## 15、防抖节流

*防抖*

- 只提交最后一次，比如你在1s内输入了10次，触发了10次inpute事件，那么前面9次都不会执行回调，只有最后一次才会

```JavaScript
let debounce = function (fn, time) {
    let timer = null;
    return function () {
        if (!timer) {
            timer = setTimeout(() => {
                fn();
            }, time)
        } else {
            clearTimeout(timer);
            timer = setTimeout(() => {
                fn();
            }, time)
        }
    }
}
```

*节流*

- 对于频繁触发的事件，比如scroll事件，为了减少回调触发次数，对其节流
- 有两种节流策略：1.当前回调执行完才能触发下一次回调，2.每隔一段时间执行一次回调

```javascript
let throatll = function (fn) {
    let isBusy = false;
    return function () {
        if(!isBusy)
        {
            isBusy = true;
            setTimeout(() => {
                fn();
                isBusy = false;
            })
        }
    }
}

let throatll2 = function (fn) {
    let lastTime = 0;
    return function(){
        let now = new Date().getTime();
        if(now - lastTime>500)
        {
            fn();
            lastTime = now;
        }
    }
}
```

## 16、手写new

- 第一步：创建一个空对象
- 第二步：原型连接将空对象的原型对象变为构造函数的原型对象；可以用object.create（proto）实现创建一个原型为proto的实例
- 第三步：显示绑定构造函数的this，并执行构造函数
- 第四步：检验构造函数的返回值
- 第五步：返回结果

```javascript
let _new = function(constructor)
{
    if(typeof constructor != 'function')
        throw new Error('请正确输入参数')
    let obj = {};
    obj.__proto__ = constructor.prototype;
    let res = constructor.call(obj,...arguments)
    return typeof res!=='object'?obj:res;
}
```

## 17、手写call、apply

- 看代码就懂了，主要利用的就是this的隐式绑定
- apply和call的区别就是apply的第二参数是数组，call的第二参数不是数组

```javascript
// 手写call
Function.prototype._call = function(context,...args){
    if(typeof context !== 'object')
        throw new Error('请正确传入参数')
    // 将函数挂载到context上
    context.fn = this;
    let res = context.fn(...args);
    // 移除context上突然多出来的fn
    delete context.fn
    // 返回执行结果
    return res;
}
```

## 18、手写bind

- bind的机制是硬绑定，把一个函数和一个this绑定在一起，然后返回一个新的函数，且这个函数的this指向不会再改变

```javascript
// 手写bind
Function.prototype._bind = function(context){
    let _this= this;
    return function(){
        return _this.call(context,...arguments)
    }
}
```

## 19、手写数组扁平化

- 将高纬度的数组降为1维
- 提供两个方案：递归、reduce
- 使用递归三个要素：参数，返回值，单层逻辑（重要）

```javascript
// 数组扁平化
// 写递归，要弄清楚参数是什么，返回值是什么，重要的是单层逻辑一定不能出错
let flatten = function(arr){
    if(!Array.isArray(arr))
    {
        throw new Error('请正确传入参数')
    }
    let ret = [];
    for(let i=0;i<arr.length;i++)
    {
        if(Array.isArray(arr[i]))
        {
            let res = flatten(arr[i]);
            ret = [...ret,...res]
        }else{
            ret.push(arr[i])
        }
    }
    return ret;
}

// 通过reduce实现数组扁平化
let flatten2 = function(arr){
    let res = arr.reduce((pre,cur,index,arr)=>{
        console.log(pre,cur,index,arr);
        if(Array.isArray(cur))
        {
            pre = [...pre,...cur]
            return pre
        }else{
            pre.push(cur)
            return pre
        }
    },[])
    return res
}
```

## 20、数组去重

```javascript
// 1.reduce
// 2.Map数据结构
// 3.Set数据结构
let removeDuplicate = function(arr){
    let res = arr.reduce((pre,cur,index,Arr)=>{
        if(pre.indexOf(cur)===-1){
            pre.push(cur)
        }
        return pre
    },[])
    return res;
}
```

## 21、手写reduce

```javascript
// 手写reduce
        Array.prototype._reduce =function(callback,initVal){
            let pre = undefined;
            let index = 0;
            if(initVal){
                pre = initVal
            }else{
                pre = this[index]
                index++
            }
            for(;index<this.length;index++){
                pre = callback(pre,this[index],index,this)
            }
            return pre
        }
        let res =  [1,2,3,4,5,6]._reduce((pre,cur)=>{
            return pre+cur
        },30)
        console.log(res);
```

## 22、0.1 + 0.2 不等于 0.3  为什么，如何解决这个问题

- JS 的 [Number类](https://so.csdn.net/so/search?q=Number类&spm=1001.2101.3001.7020)型 遵循的是 **IEEE 754** 标准，使用的是 64位固定长度来表示。
- 将 0.1 转换为二进制表示
- 将转换后的二进制通过科学计数法表示
- 将通过科学计数法表示的二进制转换为 IEEE 754 标准表示

```javascript
十进制0.1
    => 二进制0.00011001100110011…(循环0011) 
    =>尾数为1.1001100110011001100…1100（共52位，除了小数点左边的1），指数为-4（二进制移码为00000000010）,符号位为0
    => 计算机存储为：0 00000000100 10011001100110011…11001
    => 因为尾数最多52位，所以实际存储的值为0.00011001100110011001100110011001100110011001100110011001
    而十进制0.2
    => 二进制0.0011001100110011…(循环0011)
    =>尾数为1.1001100110011001100…1100（共52位，除了小数点左边的1），指数为-3（二进制移码为00000000011）,符号位为0
    => 存储为：0 00000000011 10011001100110011…11001
    因为尾数最多52位，所以实际存储的值为0.00110011001100110011001100110011001100110011001100110011
 　　　那么两者相加得：    
0.00011001100110011001100110011001100110011001100110011001
+  0.00110011001100110011001100110011001100110011001100110011　（确认？？）
    =  0.01001100110011001100110011001100110011001100110011001100
    转换成10进制之后得到:0.30000000000000004

```

- 解决方案：
  1. Number.EPSILON。这个值可以理解为一个允许误差
     - 如果0.1+0.2-0.3<Number.EPSILON就认为0.1+0.2===0.3
  2. 把计算数字 提升 10 的N次方 倍 再 除以 10的N次方。N>1.

## 23、变量提升

https://www.cnblogs.com/damonlan/archive/2012/07/01/2553425.html

1. 变量提升和函数提升：只有采用声明式函数声明的函数才会被提升，**默认情况下会先提升变量，变量提升完毕后再去提升函数**，此时如果函数名称和变量名称相同的话函数则会将变量进行覆盖，如下示例

![image-20220308150943038](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220308150943038.png)

## 24、requestAnimationFrame

https://www.jianshu.com/p/fa5512dfb4f5

https://blog.csdn.net/cwyp18809/article/details/105096048

*setTimeout的缺点*

- setTimeout的执行时间并不是确定的，setTimeout的回调要等待主线程执行结束才执行，因此 setTimeout 的实际执行时间一般要比其设定的时间晚一些。
- 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的屏幕刷新频率可能会不同，而 setTimeout只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。

*requestAnimationFram的优势*

1. 经过浏览器优化，动画更流畅
2. 窗口没激活时，动画将停止，省计算资源
3. 更省电，尤其是对移动终端
4. 最大优势：**由系统来决定回调函数的执行时机**，requestAnimationFrame的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题

## 25、onload时间和onDocumentLoaded

1. onload：当页面上的所有DOM、styleSheet、js脚本、img资源全部加载完毕才会执行
2. onDocumentLoaded：DOM构建完毕就可以执行

## 26、箭头函数this指向

1. 箭头函数是没有自己的this的，所以箭头函数中的this回去其词法作用域中去寻找
2. 词法作用域：在js中只有函数作用域和全局作用域

![image-20220308175643628](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220308175643628.png)

![image-20220308175623177](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220308175623177.png)

## 27、JS实现hash路由跳转

```js
<body>
    <div class="part1">组件1</div>
    <div class="part2">组件2</div>
    <button class="btn1">显示part1</button>
    <button class="btn2">显示part2</button>
    <script>
        // 获取dom元素
        let part1 = document.querySelector('.part1')
        let part2 = document.querySelector('.part2')
        let btn1= document.querySelector('.btn1')
        let btn2= document.querySelector('.btn2')
        // 给按钮绑定事件来修改hash值
        btn1.addEventListener('click',()=>{
            location.hash='part1'
        })
        btn2.addEventListener('click',()=>{
            location.hash='part2'
        })
        // 绑定hashchange事件
        window.addEventListener('hashchange',()=>{
            if(location.hash==='#part1')
            {
                part1.style.display = 'block'
                part2.style.display = 'none'
            }else{
                part2.style.display = 'block'
                part1.style.display = 'none'
            }
        })

    </script>
</body>
```

## 28、发布订阅模式

1. 发布订阅模式实现了发布者和订阅者的解耦，这种解耦依靠的是第三者，也就是代理人

2. 发布者维护一个代理人

3. 代理人维护用户

4. 当发布者要发布内容时，会委托代理人将内容通知到用户

   ![image-20220310132840361](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220310132840361.png)

```js
        // 发布者
        class EventPublisher{
            constructor(){
                this.eventProxy = null;
            }
            setProxy(eventProxy){
                this.eventProxy = eventProxy
            }
            // 发布者通知代理人
            // 代理人通知用户
            publish(event){
                this.eventProxy.notify(event)
            }
        }
        // 代理人
        class EventProxy{
            constructor(){
                this.events = {}
            }
            // 对用户开放订阅功能
            subscribe(event,cb){
                if(!this.events[event]){
                    this.events[event]=[]
                }
                this.events[event].push(cb)
            }
            // 通知用户
            notify(event){
                if(!this.events[event])
                {
                    throw new Error('没有人订阅')
                }
                this.events[event].forEach((cb)=>{
                    cb()
                })
            }
        }


        const eventPublisher = new EventPublisher()
        const eventProxy = new EventProxy()
        eventPublisher.setProxy(eventProxy)
        // 用户订阅
        eventProxy.subscribe('click',()=>{console.log('click事件回调触发了');})
        eventPublisher.publish('click')
```

## 29、观察者模式

1. 被观察者一旦发生变化，立马通知观察者
2. 观察者模式只需要观察者和被观察者两个角色

![image-20220310135352601](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220310135352601.png)

```js
        class Subjet{
            constructor(name){
                this.name = name
                this.observers = []
            }
            change(){
                this.observers.forEach((observer)=>{
                    observer.subChangeHandler()
                })    
            }
        }
        class Observer{
            constructor(){
                this.observeSubject = null;
            }
            observe(subject){
                this.observeSubject = subject
                subject.observers.push(this)
            }
            subChangeHandler(){
                console.log('我观察的东西发生变化了，我要做点什么');
            }
        }

        const subjectPaper = new Subjet('paper')
        const observer1 = new Observer()
        observer1.observe(subjectPaper)

        setInterval(subjectPaper.change.bind(subjectPaper),1000)
```

## 30、观察者模式和发布订阅模式的区别

![image-20220310142025852](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220310142025852.png)

*表面上的区别*

1. 发布订阅模式有三个参与者：发布者、订阅者、代理人
2. 观察者模式有两个参与者：观察者和被观察者

*稍深层次的区别*

1. 发布订阅模式实现发布者和订阅者的完全解耦
2. 观察者模式实现观察者和被观察者的松耦合

*开发使用场景的区别*

1. **观察者**模式需要在单个应用程序地址空间中实现。
2. 另一方面，**发布者/订阅者**模式更像是一种跨应用程序模式。

## 31、原生Ajax、axios、fetch

*原生Ajax*

1. 创建XmlHttpRequest对象xhr
2. 调用xhr.open构建请求
3. 调用xhr.send发送请求
4. 关于readyState：0：初始化完毕，1：open已调用，未调用send；2：send已调用，请求已经到达服务器；3：响应头已经收到，响应体开始接受但是未完成；4：HTTP响应接受完毕

*axios*

1. 使用axios.create()替代new XmlHttpRequest创建requset句柄，同时create函数可以接受配置对象进行配置如超时等待时间和BaseUrl
2. 通过request句柄调用get
3. https://www.jianshu.com/p/df464b26ae58

*fetch*

1. 直接调用fetch方法即可发送请求，该方法和axios一样也是返回一个promise

## 32、手写object.create()

1. **`Object.create()`**，该方法的作用就是创建一个新的实例对象，该实例对象的原型对象指向我们传入的这个对象
2. Object.create(proto，[propertiesObject])
3. 如果`proto`参数不是 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或非原始包装对象，则抛出一个 [`TypeError`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError) 异常。

```js
        // 接受一个对象，并产出一个以该对象为原型的实例
        Object.prototype._create = function(protoObj){
            // 参数验证
            if(typeof protoObj !== 'object')
            {
                throw TypeError('typeError')
            }
            // 创建一个空构造函数
            const Fun = function(){}
            // 连接原型链
            Fun.prototype=protoObj
            // 创建并返回对象
            return new Fun()
        }
```

- 基于Objcet.create，实现单继承

```js
// Shape - 父类(superclass)
function Shape() {
  this.x = 0;
  this.y = 0;
}

// 父类的方法
Shape.prototype.move = function(x, y) {
  this.x += x;
  this.y += y;
  console.info('Shape moved.');
};

// Rectangle - 子类(subclass)
function Rectangle() {
  Shape.call(this); // call super constructor.
}

// 子类续承父类
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;

var rect = new Rectangle();

console.log('Is rect an instance of Rectangle?',
  rect instanceof Rectangle); // true
console.log('Is rect an instance of Shape?',
  rect instanceof Shape); // true
rect.move(1, 1); // Outputs, 'Shape moved.'
```

## 33、手写Object.assign

1. Object.assign(target, ...sources)
2. 该方法的作用就是将sources对象中的属性合并到target上并返回target，如果target对象中的属性具有相同的键，则属性将被sources对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性。
3.  `Object.assign` 不会在那些`source`对象值为 [`null`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null) 或 [`undefined`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined) 的时候抛出错误。

```js
        Object.prototype._assign = function(target,...sources){
            let sourcesObj = Array.from(sources)
            sourcesObj.reduce((pre,cur,index,arr)=>{
                if(!cur)
                {
                    return target
                }
                for(let key in cur){
                    if(cur.hasOwnProperty(key)){
                        target[key] = cur[key]
                    }
                }
                return target
            },target)

            return target
        }
```

## 34、手写对象扁平化

```js
 let flatObj = function(obj){
            if(typeof obj !== 'object'){
                return TypeError('请传入object')
            }
            let res = {}
            let flat = function(curObj,prefix=''){
                if(Array.isArray(curObj)){
                    for(let key in curObj){
                        if(Array.isArray(curObj[key])){
                            flat(curObj[key],prefix+key)
                        }else if(typeof curObj[key] === 'object'){
                            flat(curObj[key],prefix+`[${key}]`+'.')
                        }
                        else{
                            res[`${prefix}[${key}]`]=curObj[key]
                        }
                    }
                }else{
                    for(let key in curObj){
                        if(curObj.hasOwnProperty(key)){
                            if(Array.isArray(curObj[key])){
                                flat(curObj[key],`${prefix}${key}`)
                            }
                            else if(typeof curObj[key] === 'object')
                            {
                                flat(curObj[key],`${prefix}${key}.`)
                            }else{
                                res[`${prefix}${key}`]=curObj[key]
                            }
                        }
                    }
                }
            }
            flat(obj)
            return res
        }

```

## 35、手写promise.all

1. promise.all接受一个promise数组，并返回一个promise
2. 所有promise都执行完成，则返回的promise状态改为fufilled，resolve所有promise执行结果数组
3. 有一个出错则返回的promise状态改为rejected，reject第一个出错的promise的原因
4. 注意：如果传入的数组中包含不是promise的元素，那么将调用promise.resolve将其包装为promise，这一步可以优化为将数组中的所有项都通过promise.resolve包装一下

```js
  Promise._all = function (promises) {
            return new Promise((resolve, reject) => {
                if (!Array.isArray(promises)) {
                    throw TypeError('we need a array')
                }
                let res = []
                let counter = 0;
                promises.map((promise) => {
                    // 这里的类型判断可以优化，直接用Promise.resolve对数组里的promise进行包装
                    // 优化前
                    // if (!(promise instanceof Promise)) {
                    //     promise = Promise.resolve(promise)
                    // }
                    // 优化后
                    Promise.resolve(promise).then((result) => {
                        res.push(result)
                        counter++
                        if (counter === promises.length) {
                            resolve(res)
                        }
                    }).catch((reason)=>{reject(reason)})    
                })

            })
        }

        const p1 = new Promise((resolve, reject) => {
            resolve('不想玩啦')
        })
        let arr = [p1, 2,2,2]
        Promise._all(arr).then((res) => {
            console.log(res);
        })
        // Promise.all(1)
```

## 36、手写promise.race

1. promise.race也是返回一个promise
2. race方法的原则就是谁先做完就返回谁
3. 同样使用Promise.resolve对数组里的每一个promise进行包装

```js
        Promise._race = function (promises) {
            return new Promise((resolve, reject) => {
                promises.map((promise) => {
                    Promise.resolve(promise).then((res) => {
                        resolve(res)
                    })
                })
            })
        }
```

## 36、add(1,2,3)等价add(1)(2)(3)

1. 考察点：柯里化（主要是用来参数复用）

```js
       let add = function(...params){
            const collectedParams = [...params]

            let inner = function(...params){
                collectedParams.push(...params)
                return inner
            }

            inner.toString = function(){
                return 'aaa'
            }

            return inner

        }
```

## 37、柯里化和偏函数

1. 区别：

   1. 柯里化将n元函数转为n个一元函数，比如fn(a,b,c)转为fn(a)(b)(c)
   2. 偏函数固定一部分函数将一个n元函数转为一个n-x元函数

2. 应用：参数复用，提前返回（https://www.cnblogs.com/goloving/p/8542817.html）

   1. 柯里化：

   ```js
           //一个二元函数转为两个一元函数
           let sum = function(a,b){
               return a+b
           }
   		// curriFunc
           let curriFunc = function(fn){
               return function(x){
                   return function(y){
                       return fn.call(this,x,y)
                   }
               }
           }
           let mySum = curriFunc(sum)
           let res =  mySum(1)(2)//3
   ```

   1. 偏函数：

   ```js
           // 手写实现偏函数：一个二元函数，固定第一个变量，变为一个2-1元函数
           let sendrequest = function(protocal,ipAddr){
               const xhr = new XMLHttpRequest()
               xhr.open('GET',protocal+ipAddr)
               xhr.send()
               xhr.onreadystatechange = function(){
                   if(xhr.readyState===4){
                       if(xhr.status>=200&&xhr.readyState<300){
                           return xhr.response
                       }
                   }
               }
           }
   
           // partial Func
           let partialFunc = function(fn,...args){
               return function(...args2){
                   fn.apply(this,args.concat(args2))
               }
           }
           let sendHttpRequest = partialFunc(sendrequest,'http//:')
           sendHttpRequest('www.baidu.com')
   ```

## 38、图片懒加载

1. 方案1：利用scroll事件，计算图片是否出现在窗口内
2. 方案2：利用intersectionObserver构造函数

```js
// 该回调函数,在图片进入视口和退出视口的时候都会执行一次
// IntersectionObserver函数会往callback中注入一个参数,event,该参数是一个事件数组,
// 包含所有被observe的dom元素的状态:event.target获取dom节点,e.isIntersecting判断是否出现在视口
const callback = function(events){
    console.log('触发');
    events.forEach(event=>{
        if(event.isIntersecting){
            // 获取data-src
            let imgSrc = event.target.getAttribute('data-src')
            event.target.setAttribute('src',imgSrc)
            // 取消观察
            obeserver.unobserve(event.target)
        }   
    })
}
// 创建观察实例,当图片未进入视口的时候会触发一次callback,当图片进入视口的时候又会执行一次
const obeserver = new IntersectionObserver(callback)
// 对每个图片都进行观察
imgs.forEach(img=>{
    obeserver.observe(img)
})
```

## 39、图片异步加载

1. 创建好的图片通过微任务插入到DOM树里

```js
function creatImg(url) {
    return new Promise((resolve, reject) => {
        const oImg = new Image();
        oImg.onload = () => {
            resolve(oImg);
        };
        oImg.onerror = () => {
            reject(new Error(`img url:${url} is not find!`));
        };
        oImg.src = url;
    });
}

const imgList = ['/timg.jpg', '/xiaohai.jpg', '/timg.jpg', '/timg.jpg'];
const oImgList = [];

imgList.forEach(imgUrl => {
    oImgList.push(creatImg(imgUrl));
});

Promise.all(oImgList).then(oImg => {
    oImg.forEach(img => {
        document.body.append(img);
    });
});
```

## 40、手写红绿灯

```js
// 手写红绿灯
let printColor = function(color,time){
    return new Promise((resolve,reject)=>{
        setTimeout(() => {
            console.log(color);
            resolve()
        }, time);
    })
}

async function print(){
    await printColor('red',3000)
    await printColor('yellow',2000)
    await printColor('green',1000)
    print()
}
```

## 41、setTimeout实现setInterval

- 为什么要这么做？
  - 如果我们用setInterval，当callback执行时间较长的时候，比如我们理想1s执行一次callback，但是callback的执行时间要3s，当callback从任务队列取出放入执行栈执行1s后，又一个callback被加入了任务队列，当执行栈中的callback执行2s后，又准备往任务队列中加callback，但是发现已经有一个了，所以就不在加入，所以本来三秒后任务队列中应该有三个回调的，此时导致只有一个

```js
const _setInterval = function(cbk,time){
    let timer = null
    let handler = function(){
        cbk()
        timer = setTimeout(handler,time)
    }
    timer =setTimeout(handler,time)
    return timer
}
```

## 42、js实现放大镜

1. little容器放小图和mask
2. big容器放大图，同时设置overflow:hidden
3. 当鼠标进入little容器，big容器和mask才会出现，同时会给little容器绑定mousemove事件
4. 当mousemove事件触发，此时可以通过offsetX和offsetY获取鼠标的坐标，
5. 注意：这个offSetX和offsetY是相对于事件源的，也就是说鼠标在哪个div身上事件源就是谁，这里是一个坑
6. 同时可以通过msak.offsetWidth获取mask的宽度（border+padding+width）
6. 注：mask和大图片都要设置为绝对定位，其父容器设为相对定位

```js
<script>
        let little = document.querySelector('.little')

        let mask = document.querySelector('.mask')
        let bigImg = document.querySelector('.big img')
        let big = document.querySelector('.big')
        const callback = function (event) {
            let mouseLeft = event.offsetX
            let mouseTop = event.offsetY
            console.log(mouseLeft, mouseTop);
            let left = mouseLeft - mask.offsetWidth / 2
            let top = mouseTop - mask.offsetHeight / 2
            if (left < 0) left = 0
            if (left > 150) left = 150
            if (top > 150) top = 150
            if (top < 0) top = 0
            mask.style.left = left + 'px'
            mask.style.top = top + 'px'

            bigImg.style.left = -2 * left + 'px'
            bigImg.style.top = -2 * top + 'px'

        }
        little.addEventListener('mouseenter', () => {
            mask.style.display = 'block'
            big.style.visibility = 'visible'
            little.addEventListener('mousemove', callback)
        })
        little.addEventListener('mouseleave', () => {
            mask.style.display = 'none'
            big.style.visibility = 'hidden'

            removeEventListener('mousemove', callback)

        })
    </script>
```

# 二、浏览器

## 1、如何解决跨域问题

1.1**理解跨域**

- 跨域指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器施加的安全限制。
- 浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。
- 比如你在www.垃圾网站.com试图访问www.银行.com，并进行某些操作，对比一看主域名不同（垃圾网站/银行），就会被拒绝

1.2**解决跨域问题**

- 但是某些情况下我们需要像后台的服务器请求数据，就不得不涉及跨域，那么如何解决呢?

​	**方式1：跨域资源共享（cors）**

- 浏览器将CORS请求分成两类：简单请求（simple request）和预检请求。
- 解决方式就是服务端在响应头中加入字段：Access-contro-allowl-origion:Origion,那么该Origion就可以访问了。如果该字段值为’*‘那么所有Origion均可访问

​	**方式2：jsonp** 

- 通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。
- 不过我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有"src"这个属性的标签都拥有跨域的能力，比如<script>、<img>、<iframe>）
- 于是可以判断，当前阶段如果想通过纯web端跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；

```javascript
//本地html文件定义回调函数，在远程js文件中调用，类似于事件总线
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title></title>
    <script type="text/javascript">
    var localHandler = function(data){
        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);
    };
    </script>
    <script type="text/javascript" src="http://remoteserver.com/remote.js"></script>
</head>
<body>

</body>
</html>

//远程调用，同时传入数据，类似于事件总线
localHandler({"result":"我是远程js带来的数据"});

```

​	**方式3：vue中设置代理服务器**

- 跨域问题只存在浏览器，如果是服务器和服务器之间的通信是不存在跨域问题的
- 可以在vue-cli中设置代理服务器实现跨域请求

## 2、浏览器缓存

- 缓存是性能优化中非常重要的一环，从三个部分来讲：强制缓存：协商缓存：缓存位置

2.1**强制缓存**

- 当浏览器准备发送请求的时候，会先检查以下本地有没有缓存（查找该请求的相关响应头里有没有相关字段，因为我们每次请求之后如果有强缓存，那么响应头里就会有cache-control字段，下一次再发请求就优先检查一下上次的响应头里有没有这个字段），检查主要是依赖和强制缓存相关的字段来查的。

- 在HTTP1.0和HTTP1.1中，这个字段是不一样的，在早期使用的是**Expires**，后面就换成了Cache-Control

- **Expires**：即过期时间，存在于服务端返回的**响应头**中，告诉浏览器在这个过期时间之前可以直接从缓存中获取数据，无需再次请求比如：

  ```
  Expires: Wed, 22 Nov 2019 08:41:00 GMT
  ```

  表示资源在`2019年11月22号8点41分`过期，过期了就得向服务端发请求。这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是**服务器的时间和浏览器的时间可能并不一致**，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。

- **Cache-Control**：在HTTP1.1中，采用一个非常关键的字段：Cache-Control这个字段也是存在于它和`Expires`本质的不同在于它并没有采用`具体的过期时间点`这个方式，而是采用过期时长来控制缓存，对应的字段是**max-age**。比如这个例子:

  ```
  Cache-Control:max-age=3600
  ```

  代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。

  如果你觉得它只有`max-age`一个属性的话，那就大错特错了。可以组合非常多的指令，完成更多此场景的缓存判断，因为一个请求可能要经过不同的`代理服务器`最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。

  private：只有浏览器能缓存，中间的代理服务器不能缓存

  no-cache：跳过当前强缓存，发送HTTP请求，直接进入协商缓存阶段

  no-store：非常粗暴，不进行任何形式的缓存

  s-maxage：这和`max-age`长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。

  值得注意的是，当**Expires**和**Cache-Control**同时存在的时候，**Cache-Control**会优先考虑。

  当然，还存在一种情况，当资源缓存时间超时了，也就是`强缓存`失效了，接下来怎么办？没错，这样就进入到第二级屏障——**协商缓存**了。

2.2**协商缓存**

- 强缓存失效之后，浏览器在请求头中携带相应的`缓存tag`来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是**协商缓存**。具体来说，这样的缓存tag分为两种: **Last-Modified** 和 **ETag**。这两者各有优劣，并不存在谁对谁有`绝对的优势`，跟上面强缓存的两个 tag 不一样。
- Last-Modified：即最后修改时间，在浏览器第一次给服务器发送请求后，服务器会在**响应头**中加上这个字段，如果浏览器再次发送请求，那么请求头中也会多出一个字段：If-Modefied-Since，这个字段的值就是服务器先前返回的Last-Modefied的值，后面的请求就会通过If-Modefied-Since字段去问服务器，有没有改动过。如果没有就继续使用缓存状态码为304，否则就返回新的资源
- ETag：是服务器根据当前文件的**内容**，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变，服务器也是通过**响应头**把这个值给到浏览器，浏览器如果再次发送请求，那么就会在请求头中加入一个新的字段：If-None-Match，这个字段的值就是ETag的值，然后发给服务器，服务器接收到**If-None-Match**后，会跟服务器上该资源的**ETag**进行比对: - 如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。 - 否则返回304，告诉浏览器直接用缓存。
- 对比：在精准度上：ETag由于Last-Modefied，由于ETag是根据文件内容给资源上标识，因此能够准确感知资源的变化，而Lats-Modefied并不能准确感知文件内容的变化：1.编辑了但没改，也会造成缓存失效，2.Last-Modefied感知的单位是秒，如果在一秒内改变了多次，这时候是感知不到的；在性能上，`Last-Modified`优于`ETag`，也很简单理解，`Last-Modified`仅仅只是记录一个时间点，而 `Etag`需要根据文件的具体内容生成哈希值。

2.3**缓存位置**

-  浏览器中的缓存位置一共有四种：\- Service Worker - Memory Cache - Disk Cache - Push Cache
- **Service Worker** ：可以把 Service Worker 理解为一个介于客户端和服务器之间的一个代理服务器。
- **Memory-Cache/Disk-Cache**：也就是内存缓存和硬盘缓存，比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存 - 内存使用率比较高的时候，文件优先进入磁盘
- **Push Cache**：即推送缓存，这是浏览器缓存的最后一道防线。

2.4**总结**

- 首先通过 `Cache-Control` 验证强缓存是否可用 - 如果强缓存可用，直接使用
- 否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的`If-Modified-Since`或者`If-None-Match`字段检查资源是否更新
- 若资源更新，返回资源和200状态码 - 否则，返回304，告诉浏览器直接从缓存获取资源

2.5**针对频繁变动的资源的策略**

![image-20220304153551345](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220304153551345.png)

## 3、浏览器的本地储存

- 浏览器的本地存储分为Cooki、WebStorage和indexedDB，其中WebStorage又可以分为LocalStorage和SessionStorage

**3.1.Cooki**

- Cooki最开始设计出来是为了弥补浏览器无状态的这个缺陷。HTTP是一个无状态的协议，客户端向服务器发请求，客户端回应，故事就这样结束了，但是下次发请求如何让服务器知道客户端是谁呢？为了解决这个问题就产生了Cooki

- Cookie 本质上就是浏览器里面存储的一个很小的文本文件，向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。

- Cookie 的作用很好理解，就是用来做**状态存储**的，但它也是有诸多致命的缺陷的：

  容量缺陷：大小仅有4k，只能用来存储少量的信息

  性能缺陷：Cooki是跟随域名发送的，所以当我们访问该域名下的任一网站时均会携带cooki，造成资源浪费。

  安全缺陷：由于Cooki以纯文本的形式在浏览器和服务器中传递很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。

**3.2.localStorage**

- 和Cooki一样，在同一个域名下会存储一段localStorage。不过和Cooki有相当多的区别：1.容量：locaStorage有5M的容量，这个5M是针对于一个域名的，对于一个域名，localstorage是永久储存
- localStorage只存在于客户端，默认不参与服务端的通信，这样就很好的避免了Cooki所带来的性能问题和安全问题
- 操作方便，可以通过getItem和setItem等方法进行操作，非常方便
- 应用场景：利用localStorage的叫大容量和持久特性，可以利用localStorage存储一些不轻易改变的资源，如该域名对应的网站logo，存储Base64格式的图片资源

**3.3sessionStorage**

- `sessionStorage`以下方面和`localStorage`一致: - 容量。容量上限也为 5M。 - 只存在客户端，默认不参与与服务端的通信。 - 接口方面。除了`sessionStorage`名字有所变化，存储方式、操作方式均和`localStorage`一样。
- 但`sessionStorage`和`localStorage`有一个本质的区别，那就是前者只是会话级别的存储，并不是持久化存储。会话结束，也就是页面关闭，这部分`sessionStorage`就不复存在了。
- 应用场景：可以用它对表单信息进行维护，将表单信息存储在里面，可以保证页面即使刷新也不会让之前的表单信息丢失。可以用它存储本次浏览记录。如果关闭页面后不需要这些记录，用`sessionStorage`就再合适不过了。事实上微博就采取了这样的存储方式。

**3.4IndexedDB**

- `IndexedDB`是运行在浏览器中的`非关系型数据库`, 本质上是数据库，绝不是和刚才WebStorage的 5M 一个量级，理论上这个容量是没有上限的。

**3.5总结**

- 1.`cookie`并不适合存储，而且存在非常多的缺陷。 2. `Web Storage`包括`localStorage`和`sessionStorage`, 默认不会参与和服务器的通信，二者的区别是前者永久存储，后者会话结束就销毁。 3. `IndexedDB`为运行在浏览器上的非关系型数据库，为大型数据的存储提供了接口。

## 4、从输入URL到页面呈现发生了什么

- https://juejin.cn/post/6844904046411644941

- 此时此刻，你在浏览器地址栏输入了百度的网址:https://www.baidu.com/

**4.1网络请求**

1. 浏览器会构建请求行：请求方式、URL地址（相对于域名下的url）、协议名，即：GET / HTTP1.1，表示的是以GET的方式通过HTTP1.1请求域名www.baidu.com下的/（根路径）资源

2. 查找强缓存

3. 如果强缓存和协商缓存皆失效，那么就再次发起请求

4. 再次发起请求，根据五层网络模型，我们首先需要知道ip地址，于是通过DNS服务器解析域名，具体流程略(查找缓存，包括浏览器缓存，操作系统缓存，路由缓存和isp缓存，如果没有缓存就进行分级查找)，最终获得了ip地址

5. 根据ip地址查找到对应的主机的MAC地址后便可以开始进行数据传输建立连接了

6. TCP三次握手，建立TCP连接

7. 发送HTTP请求：现在`TCP连接`建立完毕，浏览器可以和服务器开始通信，即开始发送 HTTP 请求。浏览器发 HTTP 请求要携带三样东西:**请求行**、**请求头**和**请求体**。

   首先，浏览器会向服务器发送**请求行**

   同时也要带上**请求头**，比如我们之前说的**Cache-Control**、**If-Modified-Since**、**If-None-Match**都由可能被放入请求头中作为缓存的标识信息。当然了还有一些其他的属性，列举如下:

   最后是请求体，请求体只有在`POST`方法下存在，常见的场景是**表单提交**。

8. HTTP 请求到达服务器，服务器进行对应的处理。最后要把数据传给浏览器，也就是返回网络响应。

   跟请求部分类似，网络响应具有三个部分:**响应行**、**响应头**和**响应体**。

   响应行类似下面这样:HTTP/1.1 200 OK，由`HTTP协议版本`、`状态码`和`状态描述`组成。

   响应头包含了服务器及其返回数据的一些信息, 服务器生成数据的时间、返回的数据类型以及对即将写入的Cookie信息。

   响应完成之后怎么办？TCP 连接就断开了吗？

   不一定。这时候要判断`Connection`字段, 如果请求头或响应头中包含**Connection: Keep-Alive**，表示建立了持久连接，这样`TCP`连接会一直保持，之后请求统一站点的资源会复用这个连接。

   否则断开`TCP`连接, 请求-响应流程结束。

4.2解析算法篇

1. 浏览器如何解析Html

   >对html的解析分为词法分析和语法分析两步：
   >
   >## 词法分析
   >
   >​	把每一种类型的token识别出来，具体类型有开始标签、结束标签、注释标签、文本标签等，这是最外层的token，开始标签内部还要分出属性
   >
   >![image-20220302145851768](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220302145851768.png)
   >
   >​	第一层判断是否包含 <，如果不包含则是 text，如果包含则再判断是哪一种，如果是开始标签，还要对其内容再取属性，直到遇到 > 就重新判断。
   >
   >​	经过词法分析，我们能拿到所有的 token：
   >
   >​	![image-20220302150207428](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220302150207428.png)
   >
   >### 语法分析(生成VDOM结构)
   >
   >​	语法分析就是对上面分出的 token 进行组装，生成 ast。html 的 ast 的组装主要是考虑父子关系，记录当前的 parent，然后 text、children 都设置到当前 parent 上。
   >
   >​	token 拆分之后，我们需要再把这些 token 组装在一起，只处理 startTag、endTag 和 text 节点。通过 currentParent 记录当前 tag。
   >
   >- startTag 创建 AST，挂到 currentParent 的 children 上，然后 currentParent 变成新创建的 tag
   >- endTag 的时候把 currentParent 设置为当前 tag 的 parent
   >- text 也挂到 currentParent 上
   >
   >![image-20220302151108073](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220302151108073.png)

4.3渲染过程篇

1. 从0，1字节流到最后页面展现在你面前，这里面渲染机制肯定很复杂，所以渲染模块把执行过程中化为很多的子阶段，渲染引擎从网络进程拿到字节流数据后，经过这些子阶段的处理，最后输出像素，这个过程可以称为`渲染流水线` ，我们从一张图上来看👇
2. ![image-20220228202403296](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220228202403296.png)

*构建DOM树*

- 这个过程主要工作就是讲HTML内容转换为浏览器DOM树结构： 字节→字符→令牌→节点→对象模型(DOM)

>*转换*：浏览器从磁盘或者网络读取HTML原始字节，并根据文件的指定编码，将字节转为字符
>
>令牌化：浏览器将字符串转换成W3C HTML5标准规定的各种令牌，这里令牌化采用的方式为
>
>词法分析：发出的令牌准换成定义其属性和规则的对象
>
>DOM构建：最后由于HTML标记定义的不同标记之间的包含关系。构建出完成的DOM树。

*样式计算*

1. 格式化样式表
2. 标准化样式表
3. 计算每个DOM节点的具体样式

>格式化样式表
>
>1. 我们拿到的也就是0，1字节流数据，浏览器无法直接去识别的，所以渲染引擎收到CSS文本数据后，会执行一个操作，转换为浏览器可以理解的结构-`styleSheets`
>2. 通过浏览器的控制台`document.styleSheets`可以来查看这个最终结果。**通过JavaScript可以完成查询和修改功能**,**或者说这个阶段为后面的样式操作提供基石。**
>
>![image-20220228203330278](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220228203330278.png)
>
>标准化样式表
>
>1. 有些时候，我们写CSS 样式的时候，会写`font-size:2em;color:red;font-weight:bold`,像这些数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，如`em`->`px`,`red`->`rgba(255,0,0,0)`,`bold`->`700`等等。
>2. ![image-20220228203443646](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220228203443646.png)
>
>计算每个DOM节点的具体样式
>
>1. 通过`格式化`和`标准化`，接下来就是计算每个节点具体样式信息了。
>
>2. 计算规则：`继承`和`层叠`
>
>   1. 继承：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫`UserAgent样式`。
>   2. 层叠：样式层叠，是CSS一个基本特征，它定义如何合并来自多个源的属性值的算法。
>   3. 不过值得注意的是，在计算完样式之后，所有的样式值会被挂在到`window.getComputedStyle`当中，也就是可以**通过JS来获取计算后的样式**，非常方便。
>
> ![image-20220228203751617](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220228203751617.png)

*创建布局树*

​	上述过程已经完成DOM树（DOM树）构建，以及样式计算（DOM样式），接下来就是要通过浏览器的布局系统确定**元素位置**，也就是生成一颗布局树（Layout Tree）,之前说法叫 **渲染树**。

>创建布局树
>
>1. 在DOM树上不可见的元素，head元素，meta元素等，以及使用display:none属性的元素，最后都不会出现在布局树上，所以**浏览器布局系统需要额外去构建一棵只包含可见元素布局树。**
>
>2. 我们直接结合图来看看这个布局树构建过程：
>
>   ![image-20220228204313069](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220228204313069.png)
>
>3. 为了构建布局树，浏览器布局系统大体上完成了下面这些工作：
>
>   1. 遍历DOM树可见节点，并把这些节点加到布局树中
>   2. 对于不可见的节点，head,meta标签等都会被忽略。对于body.p.span 这个元素，它的属性包含display:none,所以这个元素没有被包含进布局树。
>
>布局计算
>
>1. 布局的计算过程非常复杂，没有了解过、

*分层*

- 生成图层树（Layer Tree）
-  拥有层叠上下文属性的元素会被提升为单独一层
-  需要裁剪（clip）的地方也会创建图层
-  图层绘制

​	首先需要知道的就是，浏览器在构建完`布局树`后，还需要进行一系列操作，这样子可能考虑到一些复杂的场景，比如一些些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，还有比如是含有层叠上下文如何控制显示和隐藏等情况。

>生成图层树:你最终看到的页面，就是由这些图层一起叠加构成的，它们按照一定的顺序叠加在一起，就形成了最终的页面。
>
>**浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。**
>
>图层与布局树之间关系：
>
>![image-20220228204723962](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220228204723962.png)
>
>通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。**
>
>那什么情况下，渲染引擎会为特定的节点创建新图层呢？有两种情况需要分别讨论，一种是**显式合成**，一种是**隐式合成**。
>
>- **显式合成**：
>
>  - 拥有**层叠上下文**的节点。
>
>    - HTML根元素（html标签）本身就具有层叠上下文。
>
>      普通元素设置**position不为static**并且**设置了z-index属性**，会产生层叠上下文。
>
>      元素的 **opacity** 值不是 1
>
>      元素的 **transform** 值不是 none
>
>      **will-change**指定的属性值为上面任意一个。(will-change的作用后面会详细介绍)
>
>  - 需要**剪裁**(clip)的地方。
>
>    - 比如一个标签很小，50*50像素，你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条也会被单独提升为一个图层，如下图
>
>  - **元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。**
>
>- **隐式合成**
>
>  - 这是一种什么样的情况呢，通俗意义上来说，就是`z-index`比较低的节点会提升为一个单独的途图层，那么`层叠等级比它高`的节点**都会**成为一个独立的图层。
>
>-  缺点：根据上面的文章来说，在一个大型的项目中，一个`z-index`比较低的节点被提升为单独图层后，层叠在它上面的元素统统都会提升为单独的图层，我们知道，上千个图层，会增大内存的压力，有时候会让页面崩溃。这就是`层爆炸`

*绘制*

​	完成了图层的构建，接下来要做的工作就是图层的绘制了

>绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。
>
>*图块*
>
>你想呀，有时候，你的图层很大，或者说你的页面需要使用滚动条，然后页面的内容太多，多的无法想象，这个时候需要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。
>
>- 基于上面的原因，合成线程会将图层划分为图块(tile)
>-  这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。
>
>*光栅化*
>
>接着上面的步骤，有了图块之后，**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。**
>
>1. 图块是栅格化执行的最小单位
>2.  渲染进程中专门维护了一个**栅格化线程池**，专门负责把**图块**转换为**位图数据**
>3.  合成线程会选择视口附近的**图块(tile)**，把它交给**栅格化线程池**生成位图
>4.  生成位图的过程实际上都会使用 GPU 进行加速，生成的位图最后发送给`合成线程`
>
>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。

*合成和显示*

>栅格化操作完成后，**合成线程**会生成一个绘制命令，即"DrawQuad"，并发送给**浏览器进程**。
>
>浏览器进程中的`viz组件`接收到这个命令，根据这个命令，把页面内容绘制到内存，也就是生成了页面，然后把这部分内存发送给显卡
>
>用一张图来总结👇
>
>![image-20220228211331186](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220228211331186.png)

*总结*

1. 构建DOM树
   1. 字节变字符
   2. 字符变令牌
   3. 令牌变DOM
   4. 建立DOM树
2. 样式计算
   1. 字节变字符（格式化样式表）：生成document.styleSheets
   2. 标准化样式表：把语义化样式改为标准的样式，存放在getComputedStylesheet里
   3. 计算每个节点的样式：计算的依据就是继承和层叠
3. 布局阶段
   1. 生成布局树（以前也叫渲染树）
   2. 布局计算相对复杂，没有仔细了解过
4. 分层
   1. 我们所看到的页面，是由很多的图层堆叠得到的，所以要分层
   2. 分层的标准：显示分层和隐式分层（图层爆炸问题）
5. 绘制
   1. （GUI主线程）生成绘制列表
   2. 生成绘制列表后给合成线程发commit，把列表提供给合成线程
6. 分块
   1. （合成线程）
   2. 图层太多，一次性绘制效率低，所以按需绘制，所以对图层分块
   3. 优先对视口附近的图层分块
7. 光栅化
   1. （光栅线程）
   2. 将图块生成位图（*位图*也称为点阵图像或绘制图像，是由称作像素的单个点组成的）
8. 合成和显示

## 6、回流和重绘

*回流*

- 触发条件：就是当我们对 DOM 结构的修改引发 DOM 几何尺寸变化的时候，会发生`回流`的过程。
- 一个 DOM 元素的几何属性变化，常见的几何属性有`width`、`height`、`padding`、`margin`、`left`、`top`、`border` 等等, 这个很好理解。
- 使 DOM 节点发生`增减`或者`移动`。
- 读写 `offset`族、`scroll`族和`client`族属性的时候，浏览器为了获取这些值，需要进行回流操作。
- 调用 `window.getComputedStyle` 方法。
- 回流过程

![image-20220223202134599](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220223202134599.png)

*重绘*

- 触发条件：当 DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致`重绘`(`repaint`)。

- 重回过程：跳过了`生成布局树`和`建图层树`的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作。

  可以看到，重绘不一定导致回流，但回流一定发生了重绘。

![image-20220223201853923](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220223201853923.png)

*合成*

还有一种情况：就是**更改了一个既不要布局也不要绘制**的属性，那么渲染引擎会跳过布局和绘制，直接执行后续的**合成**操作，这个过程就叫**合成**。

举个例子：比如使用CSS的transform来实现动画效果，**避免了回流跟重绘**，直接在非主线程中执行合成动画操作。显然这样子的效率更高，毕竟这个是在非主线程上合成的，没有占用主线程资源，另外也避开了布局和绘制两个子阶段，所以**相对于重绘和重排，合成能大大提升绘制效率。**

- GPU加速原因：比如利用 CSS3 的`transform`、`opacity`、`filter`这些属性就可以实现合成的效果，也就是大家常说的**GPU加速**。
- 交给它处理有两大好处:

  1. 在合成的情况下，直接跳过布局和绘制流程，进入`非主线程`处理部分，即直接交给`合成线程`处理。
  1. 能够充分发挥`GPU`的优势。合成线程生成位图的过程中会调用线程池，并在其中使用`GPU`进行加速生成，而GPU 是擅长处理位图数据的。
  1. 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。

*实践意义*

1. 避免频繁使用 style，而是采用修改`class`的方式。因为会造成重绘：导致重新构建渲染树和绘制列表
2. 使用`createDocumentFragment`进行批量的 DOM 操作。减少DOM操作次数避免频繁回流
3. 对于 resize、scroll 等进行防抖/节流处理。也是为了减少回流次数
4. 添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于`tranform`, 任何可以实现合成效果的 CSS 属性都能用`will-change`来声明。这里有一个实际的例子，一行`will-change: tranform`拯救一个项目，[点击直达](https://link.zhihu.com/?target=https%3A//juejin.im/post/5da52531518825094e373372)。
4. 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）
4. 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局

## 7、跨域

http://www.ruanyifeng.com/blog/2016/04/cors.html

  *JSONP*

- 请求端定义回调函数
- 通过query参数的形式，把函数名传给服务端
- 服务端收到后，返回一个JSON数据包，这个JSON数据里面是一段script代码，同时这个script代码里还有真实数据
- 客户端拿到JSON数据包后，解析这个数据包并执行script代码，就拿到了真实数据

*CORS*

- 在服务端设置请求头：Access-control-allow-origion：*；说明所有origion可以请求该数据

*反向代理*

- 服务器和服务器之间的通讯是不存在跨域之类的问题的

## 8、什么是中间人攻击（出现在https协议中）

*SSL劫持攻击*

- SSL劫持攻击即SSL证书欺骗攻击，攻击者为了获得HTTPS传输的明文数据，需要先将自己接入到客户端和目标网站之间；在传输过程中伪造服务器的证书，将服务器的公钥替换成自己的公钥，这样，中间人就可以得到明文传输带Key1、Key2和Pre-Master-Key，从而窃取客户端和服务端的通信数据；
- 但是对于客户端来说，如果中间人伪造了证书，在校验证书过程中会提示证书错误，由用户选择继续操作还是返回，由于大多数用户的安全意识不强，会选择继续操作，此时，中间人就可以获取浏览器和服务器之间的通信数据

*SSL剥离攻击*

- 把HTTPS将为HTTP

*解决方案*

1. 建立起可靠的证书信任链：数字签名

## 9、如何存储JWT

1. https://www.jianshu.com/p/99763b817fbf

# 三、计算机网络

## 1、TCP连接

- 什么是TCP

  TCP是面向连接的，可靠的，基于字节流的传输层通信协议。

  **面向连接**：一定是一对一才能链接，不能像UDP协议可以一个主机同时向多个主机发送消息。也就是一对多是无法实现的

  **可靠的**：无论网络链路中出现了怎样的链路变化，TCP都保证一个报文一定能够到达接收端

  **字节流**：消息是「没有边界」的，所以⽆论我们消息有多⼤都可以进⾏传输。并且消息是「有序的」，当「前 ⼀个」消息没有收到的时候，即使它先收到了后⾯的字节，那么也不能扔给应⽤层去处理，同时对「重复」的 报⽂会⾃动丢弃。所以：当没有收到当前序列号的下一个序列号时，任何数据包都将被无视

- 为什么需要TCP

  因为IP层是「不可靠」的，它不保证⽹络包的交付、不保证⽹络包的按序交付、也不保证⽹络包中的数据的完整性。

- TCP连接：建立一个TCP连接需要三个信息的共识（Socket：由ip地址和端口号组成，序列号：用来解决乱序问题，窗口大小：用来做流量控制）

- 如何唯一确定一个TCP连接：TCP 四元组可以唯⼀的确定⼀个连接，四元组包括如下：源地址、源端口、目的地址、目的端口；源地址和⽬的地址的字段（32位）是在 IP 头部中，作⽤是通过 IP 协议发送报⽂给对⽅主机。 源端⼝和⽬的端⼝的字段（16位）是在 TCP 头部中，作⽤是告诉 TCP 协议应该把报⽂发给哪个进程

**1.1TCP头部格式**

![image-20220222215145244](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220222215145244.png)

- 序列号：在建立连接时，由计算机生成的随机数作为其初始值，通过SYN包（控制位SYN为1则为SYN包）传给接收端主机，每发送一次数据，就累加一次该值的大小，**用来解决网络包乱序问题**（也就是说多个包同时发出去但是不一定同时到，所以通过序列号实现顺序接受）
- 确认应答号：指下一次期望收到的数据的序列号，发送端收到这个确认应答之后，便可以认为在该序号以前的数据都被正常接收了，**用来解决不丢包问题**
- 控制位：
  - ACK：该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建⽴连接时的 SYN 包之外该位必须 设置为 1 。
  - RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。
  - SYN：该位为 1 时，表示希望建⽴连接，并在其「序列号」的字段进⾏序列号初始值的设定。 
  - FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双⽅的主 机之间就可以相互交换 FIN 位为 1 的 TCP 段。

**1.2TCP建立的三次握手**

![image-20220222223426153](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220222223426153.png)

- ⼀开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端⼝，处于 LISTEN 状态
- 客户端会随机初始化序号（ client_isn ），将此序号置于 TCP ⾸部的「序号」字段中，同时把 SYN 标志位 置为 1 ，表示 SYN 报⽂。接着把第⼀个 SYN 报⽂发送给服务端，表示向服务端发起连接，该报⽂不包含应 ⽤层数据，之后客户端处于 SYN-SENT 状态

![image-20220222223507232](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220222223507232.png)

- 服务端收到客户端的 SYN 报⽂后，⾸先服务端也随机初始化⾃⼰的序号（ server_isn ），将此序号填⼊ TCP ⾸部的「序号」字段中，其次把 TCP ⾸部的「确认应答号」字段填⼊ client_isn + 1，表示下一次应该接受序号为client_isn + 1的包, 接着把 SYN 和 ACK 标志位置为 1 。最后把该报⽂发给客户端，该报⽂也不包含应⽤层数据，之后服务端处于 SYN-RCVD 状态。

![image-20220222223727849](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220222223727849.png)

- 当客户端收到服务器发过来的SYN+ACK包后，最后又向服务端发送了一个确认包ACK，确认应答号中填入server-isn+1，然后把报文发给服务端，这次的报文可以携带客户端到服务端的数据，之后客户端处在ESTABLISH状态
- 服务器收到客户端的应答报文后也进入ESTABLISH状态
- ⼀旦完成三次握⼿，双⽅都处于 ESTABLISHED 状态，此时连接就已建⽴完成，客户端和服务端就可以相互发送数 据了

**1.3三次握手总结**

![image-20220223125757888](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220223125757888.png)

- 当需要建立TCP连接时，CLIENT会发出一个SYN包，即把控制位SYN置为1，SYN包序列号为0，确认序列号也为0，

- 当SERVER端收到CLIENT端发过来的SYN包后，做了两件事：1：为了告诉CLIENT我收到你了信息，会发送给CLIENT一个ACK包，这个包的确认号为CLIENT发过来的序列号+1，同时也要初始化自己的序列号为0，然后把这个序列号也发给CLIENT，所以SERVER会给CLIENT发送ACK+SYN包）

- 当CLIENT收到SERVER发过来的ACK包和SYN包后，也做了两件事：1是为了告诉SERVER端我收到了你发过来的序列号，所以会把该序列号的值加一放在ACK包中发给SERVER，另一方面，收到ACK包表示SERVER下一次想接受的序列号为1，所以CLIENT就把自己的序列号变为了1

- 最后两边的序列号和确认序列号都为1。

- 最后说一下为什么需要三次握手：最关键的一点就是防止已经过期的连接再次传到被链接的主机：

  - 如果采用两次的话，会出现下面这种情况。
    比如是A机要连到B机，结果发送的连接信息由于某种原因没有到达B机；
    于是，A机又发了一次，结果这次B收到了，于是就发信息回来，两机就连接。传完东西后，断开。

    结果这时候，原先没有到达的连接信息突然又传到了B机，于是B机发信息给A，然后B机就以为和A连上了，这个时候B机就在等待A传东西过去。

  - 所以两次连接主要是少了对服务端返回的连接请求的验证，三次握手好比如下对话：

    - Client对Server：我要和你贴贴
    - Server对Client：真要贴贴吗
    - Client对Server：要，（验证完毕开始贴贴）

    两次握手就像下面的对话：

    - Client对Server：（发短信，但是网络不好延时了）我要贴贴（此时Server没收到）

    - Client对Server：我们打一架（网络ok，此时Server收到了）
    - Server对Client：好，打一架
    - Server对Client：（此时Server收到前面延时的消息了）好再来贴贴吧，结果CLIENT不理SERVER，但是SERVER还在一直等待，造成了资源浪费

**1.4四次挥手**

![image-20220223143309059](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220223143309059.png)

- 客户端打算关闭连接，此时会发送⼀个 TCP ⾸部 FIN 标志位被置为 1 的报⽂，也即 FIN 报⽂，之后客户 端进⼊ FIN_WAIT_1 状态。 
- 服务端收到该报⽂后，就向客户端发送 ACK 应答报⽂，接着服务端进⼊ CLOSED_WAIT 状态。 
- 客户端收到服务端的 ACK 应答报⽂后，之后进⼊ FIN_WAIT_2 状态。 
- 等待服务端处理完数据后，也向客户端发送 FIN 报⽂，之后服务端进⼊ LAST_ACK 状态。 
- 客户端收到服务端的 FIN 报⽂后，回⼀个 ACK 应答报⽂，之后进⼊ TIME_WAIT 状态 
- 服务器收到了 ACK 应答报⽂后，就进⼊了 CLOSED 状态，⾄此服务端已经完成连接的关闭。 
- 客户端在经过 2MSL ⼀段时间后，⾃动进⼊ CLOSED 状态，⾄此客户端也完成连接的关闭。
- 这⾥⼀点需要注意是：**主动关闭连接的**，才有 TIME_WAIT 状态。

**1.5为什么是四次挥手**

- 关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端**不再发送数据了但是还能接收数据**。
- 服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服 务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接
- 从上⾯过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送， 从⽽⽐三次握⼿导致多了⼀次。

**1.6TIME_WAIT有什么用**

- 主动发起关闭连接的⼀⽅，才会有 TIME-WAIT 状态。
- 需要 TIME-WAIT 状态，主要是两个原因：
  - 防⽌具有相同「四元组」（双方的端口+ip）的「旧」数据包被收到；
  - 保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正常关 闭；
- 原因⼀：防⽌旧连接的数据包：假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发⽣什么呢？结果就是新的连接（和上一次的连接有相同的四元组）会收到上一次的连接中延迟的数据
  - 如图⻩⾊框框服务端在关闭连接之前发送的 SEQ = 301 报⽂，被⽹络延迟了。 
  - 这时有相同端⼝的 TCP 连接被复⽤后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能正常接收这 个过期的报⽂，这就会产⽣数据错乱等严᯿的问题
  - 所以，TCP 就设计出了这么⼀个机制，经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃，使得原来连 接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。
- 原因⼆：保证连接正确关闭：TIME-WAIT 作⽤是等待⾜够的时间以确保最后的 ACK 能让服务端成功接收到，从⽽帮助其正常关闭。假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？结果就是CLIENT端发出的最后一个ACK包丢失了，SERVER端收不到这个ACK就会一直处于LAST-ACK状态而无法关闭
  - 如图红⾊框框客户端四次挥⼿的最后⼀个 ACK 报⽂如果在⽹络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进⼊了 CLOSED 状态了，那么服务端则会⼀直处在 LASE_ACK 状态。 当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程就会被终 ⽌。
  - 如果 TIME-WAIT 等待⾜够⻓的情况就会遇到两种情况：服务端正常收到四次挥⼿的最后⼀个 ACK 报⽂，则服务端正常关闭连接。 服务端没有收到四次挥⼿的最后⼀个 ACK 报⽂时，则会᯿发 FIN 关闭连接报⽂并等待新的 ACK 报⽂。

![image-20220223144632301](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220223144632301.png)

**1.7为什么 TIME_WAIT 等待的时间是 2MSL？**

- MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时 间报⽂将被丢弃。
- MSL 与 TTL 的区别： MSL 的单位是时间，⽽ TTL 是经过路由跳数。所以 MSL 应该要⼤于等于 TTL 消耗为 0 的 时间，以确保报⽂已被⾃然消亡
- TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是： ⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包 被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间
- ⽐如如果被动关闭⽅没有收到断开连接的最后的 ACK 报⽂，就会触发超时᯿发 Fin 报⽂，另⼀⽅接收到 FIN 后， 会᯿发 ACK 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。 2MSL 的时间是从客户端接收到 FIN 后发送 ACK 开始计时的。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没 有传输到服务端，客户端⼜接收到了服务端᯿发的 FIN 报⽂，那么 2MSL 时间将重新计时

**1.8TIME_WAIT 过多有什么危害**

- 客户端受端⼝资源限制：客户端TIME_WAIT过多，就会导致端⼝资源被占⽤，因为端⼝就65536个，被占满就会导致⽆法创建新的连 接
- 服务端受系统资源限制：由于⼀个四元组表示 TCP 连接，理论上服务端可以建⽴很多连接，服务端确实只监听⼀个端⼝ 但是会把连接 扔给处理线程，所以理论上监听的端⼝可以继续监听。但是线程池处理不了那么多⼀直不断的连接了。所以当 服务端出现⼤ᰁ TIME_WAIT 时，系统资源被占满时，会导致处理不过来新的连接。

1.9**超时重传**

1. https://blog.csdn.net/qq_41431406/article/details/97926927

## 2、UDP 和 TCP 有什么区别

- UDP 不提供复杂的控制机制，利⽤ IP 提供⾯向「⽆连接」的通信服务
- UDP 协议真的⾮常简，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：
- ![image-20220222221050559](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220222221050559.png)
- ⽬标和源端⼝：主要是告诉 UDP 协议应该把报⽂发给哪个进程。 包⻓度：该字段保存了 UDP ⾸部的⻓度跟数据的⻓度之和。 校验和：校验和检验UDP报文是否有错，如果有错就重传

**2.1区别**

- 连接；TCP是面向连接的传输层协议，传输数据前要先建立连接；UDP是面向无连接的传输层协议，传输数据时不需要连接
- 通信对象数量：TCP是一对一的两点服务，也就是说只能是一个连接的两端进行通信；UDP因为是面向无连接的，所以只管发送，因此可以支持一对一；一对多；多对多
- 可靠性：TCP是可靠的连接，数据可以做到不重复、不丢失、按需到达；UDP是不可靠的数据传输，不能保证数据不重复、不丢失、以及可靠交付
- 拥塞控制、流量控制：TCO有拥塞控制和流量控制机制，保证数据传输的安全性；UDP则没有，即使网络非常拥堵了也不会影响UDP的发送速率
- 首部开销：TCP首部有源端口、目标端口、序列号、确认应答号、控制位、窗口大侠、校验和、紧急指针共计20个字节。UDP首部有源端口、目标端口号、包长度、校验和共8字节
- 传输方式：TCP是流式传输没有边界，单保证顺序和可靠性，UDP是一个包一个包的发送，是有边界的，但可能会丢包和乱序
- 分片不同：TCP 的数据⼤⼩如果⼤于 MSS ⼤⼩，则会在传输层进⾏分⽚，⽬标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了⼀个分⽚，只需要传输丢失的这个分⽚。UDP 的数据⼤⼩如果⼤于 MTU ⼤⼩，则会在 IP 层进⾏分⽚，⽬标主机收到后，在 IP 层组装完数据，接着再 传给传输层，但是如果中途丢了⼀个分⽚，在实现可靠传输的 UDP 时则就需要᯿传所有的数据包，这样传输 效率⾮常差，所以通常 UDP 的报⽂应该⼩于 MTU

## 3、HTTP

**3.1HTTP常见状态码**

![image-20220223152141965](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220223152141965.png)

- 1XX
  - 100：continue。客户端应该继续其请求
  - 101： Switching Protocols。切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议
- 2XX
  - 200：OK请求成功
  - 204：NO-Content
  - 206：partial-Content
- 3XX
  - 301：永久重定向，301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。
  - 302：临时重定向
  - 304：NOT-Modefied：表示内容未修改，也叫做缓存重定向，用于缓存控制
- 4XX
  - 400：客户端错误，说明请求报文出错，比较笼统
  - 403：Forbbiden，禁止访问
  - 404：Not Found，目标资源未找到
- 5XX
  - 500，服务器错误，比较笼统
  - 501，NOT implement，表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。
  - 502， Bad Gateway，代理服务器访问真正的后端服务器发生了错误
  - 503， Service Unavailable，表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后᯿试”的意 思。

**3.2HTTP常见字段**

- HOST：当前域名
- Accept：表示可以接受的数据类型
- Accept-Encoding：表示可以接受的压缩文件格式
- content-type：服务返回的类型
- content-length：服务器返回的数据长度
- content-Encoding：服务器返回的数据的压缩方式
- connect：keep-alive：保持长连接

**3.3GET与POST**

- Get：⽅法的含义是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等
- POST：⽽ POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥
- GET是安全和幂等的，GET请求只是从服务器读取数据，不会对数据进行任何的修改，因此无论发起多少次GET请求都不会对服务器的数据造成任何影响，所以是安全的也是幂等的
- POST请求，由于可以更改服务器的数据，因此不是安全和幂等的

**3.4HTTP特性**

- 简单：基本报文格式就是HEADER+BODY，而且都是键值对的形式，易于理解
- 灵活易拓展：HTTP报文的字段不是固定不变的，可以自定义字段，易于拓展
- 应用广泛和跨平台：从台式机的浏览器到⼿机上的各种 APP，从看新闻、刷贴吧到购 物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性

**3.5HTTP的缺点**

- 短链接
- 明文传输
- 无状态
- 不安全

**3.6HTTP1.1性能**

*长连接*

- HTTP 协议是基于 TCP/IP，并且使⽤了「请求 - 应答」的通信模式，所以性能的关键就在这两点⾥
- HTTP1.1支持长连接：早期HTTP1.0性能上很大的一个问题就是短链接，没发起一个请求都要建立一次连接，经理一次三次握手增加了通信开销
- 为了解决上述问题HTTP1.1提出了长连接，降低了TCP连接的重复建立和断开所造成的额外开销

*管道传输网络*

- HTTP1.1采用了长连接的方式，这使得管道网络成为了可能，也就是说只要第⼀个请求发出去了，不必等其回来，就可以发第 ⼆个请求出去，可以减少整体的响应时间。
- 但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求 排队等着。这称为「队头堵塞」

*队头堵塞*

- 因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致 客户端⼀直请求不到数据，这也就是「队头阻塞」。好⽐上班的路上塞⻋
- 总之 HTTP/1.1 的性能⼀般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能

**3.7HTTP常见请求方法**

1. GET：发送请求来获得服务器上的资源，请求体中不会包含请求数据，请求数据放在协议头中。幂等
2. POST：和get一样很常见，向服务器提交资源让服务器处理，比如提交表单、上传文件等，可能导致建立新的资源或者对原有资源的修改。提交的资源放在请求体中。 Post 请求用于创建新的资源，这意味着每次调用都会在系统中产生新的资源，所以该操作注定不是幂等操作。
3. HEAD： 本质和get一样，但是响应中没有呈现数据，而是http的头信息，主要用来检查资源或超链接的有效性或是否可以可达、检查网页是否被串改或更新，获取头信息等，特别适用在有限的速度和带宽下。
4. PUT：和post类似，发送资源与服务器，并存储在服务器指定位置，要求客户端事先知道该位置；比如post是在一个集合上（/province），而put是具体某一个资源上（/province/123）。Put操作必须为幂等的，即如果声明为Put协议时就相当于对外声明这个接口是幂等的。
5. DELETE：Delete 方法用于删除资源，虽然改变了系统资源，**但是第一次和第N次删除操作对系统的作用是相同的**，所以是幂等的。
6. OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法

## 4、HTTPS

**4.1HTTPS和HTTP的区别**

- HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。
- HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之 后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输
- HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的

**4.2HTTPS解决了HTTP的哪些问题**

- 窃听风险：别人无法获取你的数据了
- 篡改风险：别人无法修改你的内容
- 冒充风险：别人无法冒充你了

**4.2HTTPS如何解决上述问题**

- 混合加密解决了窃听风险，别人拿到的都是加密的信息
- 摘要算法保证了数据的完整性，解决了篡改风险
- 将服务器公匙放在数字证书中，解决了别人冒充服务器的风险
- https://www.cnblogs.com/shijingjing07/p/5965792.html

*混合加密*

- 对称加密：客户端给服务器一个随机数和一个加密方法列表，服务器返回一个随机数和一个加密方法。所以现在两者共有的资源为：两个随机数一个加密方法。然后就可以用加密方法加密数据，用随机数组合成钥匙解密数据。缺点是这三个东西都会以明文传输的形式进行传输，因此可能会被窃听。这时候加密就没有意义了
- 非对称加密：客户端给一个随机数和和一个加密方法列表，客户端返回一个随机数和一个公匙，客户端用公匙对数据加密发给服务端，服务端手上还有一个私钥，用私钥解密公钥的报文，同时也可以用公钥解密私钥的报文。两者用的不是同一个密钥所以是非对称加密，非对称加密的缺陷在于，公钥还是会被窃听到。那就可以用来解开私钥加密的内容了这样就可能被修改，为了保证数据完整修就有了摘要算法。还有一个问题就是万一本机的公钥被换成黑客的公钥了，然后黑客就可以冒充服务器获得你的数据了，为了保证公钥一定来自于服务器，就有了数字证书，用CA公钥解密数字证书就能拿到真正的服务器公钥，有了数字证书就不用担心公钥被掉包的情况了。
- 混合加密：在非堆成加密的基础上，客户端用生成第三个随机数，并用公钥加密然后发给服务器，因为这第三个随机数是用公钥加密的，所以这个数是安全的，因为别人没有私钥。所以用这个数和之前的两个数做成密码，别人就永远解不开了。

*摘要算法*

- 为了保证数据的完整性，会对报文进行处理，显示对内容进行hash解算，得到摘要，然后服务器用私钥加密这个摘要生成签名，这样客户端接收到数据后，先用公钥解密签名生成摘要然后对比内容摘要和签名摘要，如果一样就说明没有被更改。

*数字证书*

- 数字证书主要是解决公钥不安全的情况，一旦公钥被掉包，你发送的文章对于拥有私钥的黑客就是透明的，所以为了保证公钥的安全，服务器会像CA进行认证，CA通过CA私钥生成一个服务器的数字证书，里面包含了服务器的公钥，客户端就不必手持服务器公钥了，只要拥有CA公钥就可以打开服务器发过来的数字证书，拿到真正的属于服务器的公钥而不用担心公钥被掉包。
- 首先，客户端向服务器发出加密请求。
- 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。
- 客户端进行解密（客户端内部维护着受信任的证书颁发机构的列表，也就是说有这些机构的公钥）。
- 如果解不开：就会警告：网站证书不可信
- 如果解开了，但是网站信息不对：就会警告安全证书有问题，你想访问的网站和证书上的网站不是同一个网站，继续访问就会进入证书上记录的冒充网站

## **5、HTTP/1.1、HTTP/2、HTTP/3 演变**

*HTTP/1.1 相⽐ HTTP/1.0 性能上的改进：*

- 使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。
- ⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以 减少整体的响应时间
- 缺陷：
  - 发送冗⻓的⾸部。每次互相发送相同的⾸部造成的浪费较多
  - 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞
  - 没有请求优先级控制
  - 请求只能从客户端开始，服务器只能被动响应

*那 HTTP/2 相⽐ HTTP/1.1 性能上的改进：*

- 首部压缩（HPACK）：解决了头部资源浪费问题
- 二进制格式：头信息和数据体都是二进制，并且统称为帧，：头信息帧和数据帧
- 数据流：HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据 包做标记，指出它属于哪个回应。客户端还可以指定数据流的优先级。优先级⾼的请求，服务器就先响应该请求
- 多路复用：HTTP/2 是可以在⼀个连接中并发多个请求或回应，⽽不⽤按照顺序⼀⼀对应。也就是说不用顺序回应，也就解决了队头阻塞问题https://juejin.cn/post/6844903935648497678
- 服务器推送：HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。常 见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请 求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。
- 缺陷：
  - HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求 的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的᯿传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等 待这个丢了的包被重传回来
  - HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了
  - HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求
  - 这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP

*HTTP/3*

- HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP
- UDP 发⽣是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的⼀个丢包全部᯿传问 题
- ⼤家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输
- QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到 影响。
- TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。 HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把 以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数

## 6、HTTP1.1优化

![image-20220223190853108](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220223190853108.png)

总结：

- 第⼀个思路是，通过缓存技术来避免发送 HTTP 请求。客户端收到第⼀个请求的响应后，可以将其缓存在本地磁 盘，下次请求的时候，如果缓存没过期，就直接读取本地缓存的响应数据。如果缓存过期，客户端发送请求的时候 带上响应数据的摘要，服务器⽐对后发现资源没有变化，就发出不带包体的 304 响应，告诉客户端缓存的响应仍然 有效

- 减少 HTTP 请求的次数，有以下的⽅法：

  - 将原本由客户端处理的᯿定向请求，交给代理服务器处理，这样可以减少᯿定向请求的次数
  - 将多个⼩资源合并成⼀个⼤资源再传输，能够减少 HTTP 请求次数以及 头部的᯿复传输，再来减少 TCP 连接 数ᰁ，进⽽省去 TCP 握⼿和慢启动的⽹络消耗
  - 按需访问资源，只访问当前⽤户看得到/⽤得到的资源，当客户往下滑动，再访问接下来的资源，以此达到延迟 请求，也就减少了同⼀时间的 HTTP 请求次数

- 第三思路是，通过压缩响应资源，降低传输资源的⼤⼩，从⽽提⾼传输效率，所以应当选择更优秀的压缩算法

  

# 四、CSS

## 1、水平垂直居中

- 内联元素居中布局
  - 水平居中
    - 行内元素可设置：text-align: center;
    - flex布局设置父元素：display: flex; justify-content: center;
  - 垂直居中
    - 单行文本父元素确认高度：height === line-height
    - 多行文本父元素确认高度：vertical-align: middle;
- 块级元素居中布局
  - 水平居中
    - 定宽: margin: 0 auto;
    - 不定宽： posiotion+transform。
  - 垂直居中
    - position: absolute设置left、top、margin-left、margin-to(定高)；
    - transform: translate(x, y)；

## 2、BFC

*触发条件*

- float的值不是none。
- position的值不是static或者relative。
- display的值是inline-block、table-cell、flex、table-caption或者inline-flex
- overflow的值不是visible

*作用*

- 避免margin重叠：因为属于同一个BFC
- 清除浮动

https://blog.csdn.net/sinat_36014216/article/details/105468541?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&utm_relevant_index=1

## 3、元素宽高属性总结

5.1**元素的宽高**

- 它们都是Element的属性，表示元素的宽度。
- Element.scrollWidth  内容+内边距+溢出尺寸
- Element.offsetWidth 元素的宽度（***\*内容+内边距+边框+滚动条\****）==整体，整个控件

- Element.clientWidth  内容+内边距,-----**不包括边框和外边距、滚动条** == 可视内容

5.2**元素坐标**

- 获取鼠标在页面的相对坐标
- event.clientX：客户区域内的水平坐标
- event.clientY：客户区域内的垂直坐标
- event.scrollX：鼠标指针在屏幕坐标中的水平坐标
- event.scrollY：鼠标指针在屏幕坐标中的垂直坐标
- event.pageX：返回相对于整个文档的左边缘单击鼠标的X（水平）坐标，包括当前不可见的文档的任何部分
- 非标准非IE支持的
- event.offsetX ：鼠标指针在该事件与目标节点的填充边缘之间的X坐标中的偏移量。 
- event.offsetY：鼠标指针在该事件与目标节点的填充边缘之间的Y坐标中的偏移量。 

## 4、清除浮动的方法

1. BFC：块级格式上下文，计算高度的时候会计算浮动元素
2. clear属性：给父级元素添加clear属性
3. 伪元素：after，before。在当前元素内部插入一个元素，伪元素的使用必须为其添加content属性，同时因为clear要作用于块级元素，所以要将其转为块级元素

## 5、盒模型

1. 盒模型：页面布局的基本单位，由：margin+border+padding+content构成
2. W3C标准盒模型（content盒模型）：width仅仅指的是content部分的宽度，额外设置border、padding的话会把盒子撑大（box-sizing：content-box）
3. IE盒模型（border盒模型）：width指的是整个盒子的宽度，如果设置了border和padding，那么就会压缩content的宽度：通过box-sizing：border-boxs将盒模型设置为IE盒模型

# 五、Vue2

## 1、生命周期

>从created到beforeMount的过程中，
>
>首先会判断vue实例中有没有el选项，如果有的话则进行下面的编译，但是如果没有el选项，则停止生命周期，直到vue实例上调用vm.$mount(el)。
>如果有el，再判断是否有template参数，如果有，则把其当作模板编译成render函数，如果没有，则把外部的html作为模板编译。template中的模板优先级高于outer HTML模板。
>在vue对象中还有一个render函数，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX.
>综合排名优先级：render函数选项 > template选项 > outer HTML

![image-20220301223803458](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220301223803458.png)

上图依次向下为：

- beforeCreated：这个时期，this变量还不能使用，在data下的数据，和methods下的方法，watcher中的事件都不能获得到
- created：这个时候可以操作vue实例中的数据和各种方法，但是还不能对"dom"节点进行操作；
- beforeMounted：在挂载开始之前被调用：相关的 render 函数首次被调用。
- mounted：挂载完毕，这时`dom`节点被渲染到文档内，一些需要`dom`的操作在此时才能正常进行
- beforeUpdate：在这一阶段，vue遵循数据驱动DOM的原则；beforeUpdate函数在数据更新后虽然没立即更新数据，但是DOM中的数据会改变，这是Vue双向数据绑定的作用。
- updated：在这一阶段DOM会和更改过的内容同步
- beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。
- destroyed：该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。

## 2、vue响应式原理

1. 核心API-Object.defineProperty

2. 如何实现响应式

   1. 监听对象：传入一个对象，遍历对象身上的所有属性，然后对每个属性都进行劫持（也就是重新定义一个一样的属性，就把原来的属性给劫持（覆盖）了）
   2. 复杂对象深度监听：在defineReactive中调用依次observer

   1. 监听数组：如果监听的对象obj是一个数组，那个就修obj的原型

3. Object.defineProperty的缺点

   1. 深度监听，需要递归到底，一次性计算量大，（如果非常非常大页面直接卡死）
   2. 无法监听新增属性和删除属性（Vue.$set,Vue.$delete）
   3. 无法监听数组

## 3、v-show和v-if

1. v-show只重绘不回流，而是通过CSS display：none控制显示和隐藏
2. v-if会导致回流，因为v-if会真正的销毁和重建组件，而不是显示和隐藏
3. 频繁切换用v-show否则用v-if

## 4、Vue父子组件生命周期

​	在父组件挂在前创建子组件并挂载子组件，然后挂载父组件

- **父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted。**

## 5、为何在v-for中用key

1. 必须用key因为diff算法中通过tag和key来判断新旧节点是不是sameNode
2. 减少渲染次数，提升渲染性能
3. 不能使用index和ramdom

## 6、Vue组件如何通讯（常见）

1. 父子通信：props
2. 子父通信：父组件给子组件绑定自定义事件
3. 兄弟通信：全局事件总线，$bus，vuex

## 7、描述组件渲染和更新的过程

![image-20220302213916432](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220302213916432.png)

1. **vue-template-compiler将模板编译成render函数**：然后执行render函数生成vDom，在执行render函数的过程中会触发某些被劫持的数据的getter，即‘touch’，随后这个数据就会被观测者观测到，一旦该数据的setter被触发，就会通知监测者，然后就会触发页面重新渲染
2. 黄色部分：模板编译：vue-template-compiler，将模板编译成vdom
3. 紫色部分：数据响应式
4. 蓝色部分：观测者执行页面重新渲染

## 8、v-model的实现原理

1. 表单元素内容改变时触发对应事件修改data中的数据，实现view到model的绑定：this.name = $event.target.value
2. 当data中的数据发生修改时，触发setter，重新渲染视图，实现model到view的绑定

## 9、computed有何特点

1. 缓存：如果计算属性所依赖的数据不发生变化，那么就不会重新计算
2. 所以合理利用computed可以提高性能

## 10、为何组件data必须是一个函数？

1. vue文件看似暴露的是一个对象，其实是一个类，每次使用的时候都需要new出来，如果data是一个对象，那么所有组件实例都将共享这个data
2. 如果data是一个对象，那么当一个组件被多次复用时，这些组件的data都指向同一块内存地址，这就导致一个组件的data更改会影响到其他的组件

## 11、ajax应该放在哪个生命周期

1. 应该放在mounted中，如果放在created中也不是不行，但是会使得代码看起来更加的混乱。因为生命周期是同步的，如果在created中发送ajax请求，那么就会有异步分支出现，如果放在mounted中发送ajax请求，ajax异步回调会直接加入主线程进行执行，整个过程更加的整洁

## 12、多个组件有相同的逻辑如何抽离

1. 使用mixin

![image-20220302222542241](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220302222542241.png)

## 13、何时使用异步组件

1. 异步组件支持promise，故将组件写在excutor中的resolve中即可
2. 加载大型组件时
3. 路由组件异步加载

```js
Vue.component('async-example', function (resolve, reject) {
  setTimeout(function () {
    // 向 `resolve` 回调传递组件定义
    resolve({
      template: '<div>I am async!</div>'
    })
  }, 1000)
})

Vue.component(
  'async-webpack-example',
  // 这个动态导入会返回一个 `Promise` 对象。
  () => import('./my-async-component')
)

new Vue({
  // ...
  components: {
    'my-component': () => import('./my-async-component')
  }
})
```

## 14、何时需要使用keep-alive

1. keep-alive：缓存组件，不需要重新渲染
2. 如多个tab页的切换
3. 优化性能

## 15、何时使用beforeDestory

1. 解绑自定义事件：event.$off，如果不清除有可能会造成内存泄漏
2. 清除定时器
3. 解绑自定义DOM事件（addeventListener）如window.scroll等，自己操作dom绑定的事件自己解除，不是自己绑定的而是通过vue绑定的就不用我们管；
4. 这三者不做的话都可能会造成内存泄漏

## 16、什么是作用域插槽

1. 父组件向子组件传入html结构，但是html中的数据来自于子组件，所以父组件要拿到子组件的数据，可以通过scope属性获得子组件通过slot标签传过来的数据

## 17、vuex中action和mutation的区别

1. action中可以处理异步操作，mutation不可以
2. mutationy用于做原子操作
3. action可以整合多个mutation

## 18、vue-router常用的路由模式

1. hash：主要是借助location.hash来获取和修改url的hash值、随后通过onhashchange事件来操作显示哪个组件

```js
    <script>
        let btns = Array.from(document.querySelectorAll('button'))
        let com1 = document.querySelector('#com1')
        let com2 = document.querySelector('#com2')
        // 绑定点击事件修改hash
        btns.forEach((btn, index, arr) => {
            btn.addEventListener('click', () => {
                location.hash = index;
            })
        })
        // 监听onhashchange展示不同组件
        window.onhashchange = function () {
                console.log(location.hash);
                if (location.hash === '#1') {
                    com1.style.display = 'none'
                    com2.style.display = 'block'
                } else {
                    com2.style.display = 'none'
                    com1.style.display = 'block'
                }
            }
    </script>
```

1. history（需要服务端支持）：通过history.pushState方法修改url而不引起页面刷新；history.pushState和history.push两者都可以将一个url加入history栈，区别就是前者不会像后端发起请求，而后者就会像服务器发起请求，随后可以通过onpopstate事件监听url的切换

```js
    <script>
        let btns = Array.from(document.querySelectorAll('button'))
        let com1 = document.querySelector('#com1')
        let com2 = document.querySelector('#com2')
        btns.forEach((btn, index, arr) => {
            btn.addEventListener('click', () => {
                history.pushState('','','com1')
                console.log('我将在这里显示com1组件')
                com1.style.display='block'
            })
        })
        window.onpopstate = function(e){
            console.log(e);
        }
    </script>
```

1. https://blog.csdn.net/jsjxlhj/article/details/119957971?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4.pc_relevant_default&utm_relevant_index=9

## 19、如何实现路由异步加载

1. 通过import函数

![image-20220303210959533](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220303210959533.png)

## 20、用vnode描述一个dom结构

​	左图：DOM结构

​	右图：VNode

![image-20220303231547585](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220303231547585.png)

## 21、diff算法的时间复杂度

1. O（n），使用O（n三次方）调整过来的，
2. 原本DOM树的diff算法：遍历tree1；遍历tree2；排序，三次方复杂度
3. 只比较同一层级，不跨级比较
4. tag不同直接删掉重建，不做深度比较
5. tag和key都相同则认为是相同节点，不再深度比较

## 22、vue配置项如何转为js代码

1. 这个地方考察的应该是模板编译

## 23、简述diff算法过程

1. 首先调用patch（elem，vnode）或patch（vnode，newVnode）
2. 然后调用patchVnode，patchVnode中然后调用了addVnodes和removeVnodes
3. 最后patchVnode中调用了updateChildren

## 24、Vue为何是异步渲染的，$nextTick

1. vue异步渲染主要是为了提升渲染性能，如果每每改变一个被vue监测的数据都要触发一次rerender，那么效率将会非常的低下，所以vue做出的选择是一次性收集所有的改动，然后一次性rerender，这样就大大的减少了渲染的次数
2. nextTick：
   1. nextTick函数是一个通过立即执行函数返回的闭包，该立即执行函数中定义了一个属性callback数组，用来存放nextTick所接受的回调，然后定义了一个nextTickHandler 函数用来遍历执行callback数组，随后该立即执行函数会对当前浏览器所支持的异步功能进行一个判断，如果支持promise，那么就将nextTickHandler 放到promise的then方法中，作为微任务执行，如果不支持promise但是支持mutationObserver，那么就将nextTickHandler 作为mutationObserver的回调函数，同时利用mutationObserver监视一个文本节点，然后每次都改变这个文本节点就会触发nextTickHandler 实现遍历。如果也不支持mutationOberserver，那么就使用setTimeout异步执行nextTickHandler 。至此初始化完毕
   2. 执行nextTick方法，首先会将传入的回调函数外在包装一个函数，然后压入callback数组中，随后检查当前是否正在执行回调（利用标志位pendding）如果没有，那么就调用timeFunc异步调用
   3. https://www.jianshu.com/p/a7550c0e164f 

## 25、Vue常见性能优化

1. 自定义事件、dom事件的及时销毁（放在beforedestory中）
2. 合理使用异步组件：面对比较大的组件可以使用异步组件
3. 合理使用keep-alive
4. data层级不要太深
5. 使用vue-loader在开发环境做预编译（减少首屏白屏时间）
6. 通用优化：图片懒加载（https://blog.csdn.net/w1418899532/article/details/90515969）
7. 使用SSR，服务端渲染

## 26、vue.set原理

1. vue.set可以对我们的响应式数据进行补充，比如我要增加新的响应式数据，但是又不能去更改源码，那么就可以通过vue.set去增加
2. 通过下标修改数组而不触发响应式的问题也可以通过vue.set修复，如果我们通过vue.set修改数组内容，那么set函数会调用经过重写的splice函数对我们的数组进行修改，因为splice函数是经过重写的，因此可以触发响应式
3. https://www.cnblogs.com/yaxinwang/p/13827529.html

## 27、模板编译&响应式

 ***虚拟DOM和diff***

1.历史缺陷****

- DOM操作比较耗时：[为什么说DOM操作很慢 - johnhery - 博客园](https://www.cnblogs.com/johnhery/p/9859064.html)
- 以前用jQuery，可以自行控制DOM操作时机。
- Vue和React都是数据驱动视图。不必手动操作DOM那么这个时候如何有效控制DOM操作？Vue和React是怎么做的？ 

2.解决方案**：**vdom****

- vdom-用js模拟dom结构，计算出最小变更，然后再去操作DOM，不是说不去操作DOM而是说尽量减少对dom的操作

3.用JS模拟dom结构 

![img](https://img-blog.csdnimg.cn/1b0b47c5017b4365b52aaa140ddc388a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR54ix5a2m5LmgJiblrabkuaDniLHmiJE=,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

****4.snabbdom****库****

​    示例：通过h函数生成一个vnode，这个vnode就和上面的js表示的**vnode数据结构**很像了，  ****

![img](https://img-blog.csdnimg.cn/e33b5250bfe44a0cab6a4c4109c4678d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR54ix5a2m5LmgJiblrabkuaDniLHmiJE=,size_17,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

​    h**函数**：创建vnode 

​    **patch函数 ：** 初次渲染时通过patch函数将vnode变成真正的dom元素，后续还可以通过patch函数实现dom更新，patch（vnode，null）将执行销毁dom元素

5.vdom总结

- 用js模拟dom结构（vnode）
- 新旧vnode对比，得出最小的更新范围，最后更新DOM
- 数据驱动视图的模式下。能够有效控制DOM操作，减少不必要的dom操作提升性能

**6.diff算法**

- 只比较同一层级，不跨级比较，也就是每次只比较dom树的一层，是一个层级遍历分析的策略，也就是广度优先，

![img](https://img-blog.csdnimg.cn/ca6fa130388846a6be0b2bea4b1dc459.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR54ix5a2m5LmgJiblrabkuaDniLHmiJE=,size_11,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

- tag（标签）不同，则直接删掉，不再深度比较，尽管下一级的节点可能相同，但是也不管了，直接删除

![img](https://img-blog.csdnimg.cn/b1f23bed90314276bbd2430f5d205c80.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR54ix5a2m5LmgJiblrabkuaDniLHmiJE=,size_14,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

- tag和key两者都相同，则认为是相同节点，进入patchVnode，所以说key的作用体现在哪？上面说到tag不同就要直接删掉重建，那么有些情况是光有tag是不够的，所以加了个key来进行判断 

7.源码解读

-  patch函数： 
  1. 执行pre hook，
  2. 参数验证：如果第一个参数不是一个vnode而是一个dom元素比如说是一个div，那么此时也就是对应第一渲染的时候，那么就创建一个空的vnode，然后把这个空的vnode和这个dom元素关联在一起
  3. 判断是否是相同的vnode：根据tag和key来判断两者是不是相同的vnode，如果不相同就删掉重建，注意：如果不传入key，那么key就是undefined，如果是同一个vnode，那么就进入patchVnode函数
  4. patchVnode：该函数接受oldVnode和vnode，首先调用prepatch hook，进行一些初始化，然后设置vnode.elem，也就是说我们新创建的虚拟dom本来是没有对应的dom元素的，为了让vnode找到它应该跟哪个dom元素产生关联，我们要给他设置一个elem属性，采用的方式是vnode.elem=oldVnode.elem
  5. patchVnode：如果vnode的子节点是文本节点，那么就简单了，比较一下一样不一样，如果一样就不动，如果不一样，直接把原来的干掉换成新的
  6. patchVnode：如果vnode的子节点不是文本节点，那么有如下逻辑：新旧vnode都有children属性，那么调用updateChildern函数；如果新vnode有旧vnode没有，那旧vnode虽然没有childern，但是可能有text，所以先清除旧vnode的text子节点，然后再把新vnode的children通过调用dom相关的API操作dom增加进去，
  7. updateChildren函数：此时新旧vnode都有children属性，两个children数组，通过双指针算法进行对比，对比规则：1.头头相比，2.尾尾相比，3.新头旧尾，4.旧头新尾，，慢慢的直到全部child节点对比完成，如果命中，就调用patchVnode对vnode进行更新
  8. updateChildren函数：如果一种都没有命中，那就看看新vnode中当前index所指向的child节点的key，在旧vnode的child数组中有没有对应的key存在，如果没有对应上，直接重建，如果对应上了，就拿到这个对应上的节点，再看看标签是否相等，如果不等，就重建，如果相等就patchVnode
- 由此可以看出key的作用了，如果不加key，那么默认所有的key都是undefined，那么在updateChild阶段，如果出现了四种情况都未命中的情况，那么会频繁的调用pathVnode，因为此时判断是否为同一个节点的条件放宽了，那么patchVnode的活也就变多了，效率就低了

8.diff算法总结

- patchVnode，更新当前正在对比的Vnode
- addVnodes，removeVnodes，增加删除DOM
- updateChildren，对比当前节点的孩子们
- 细节不重要updateChildren的过程也不重要 
- vdom核心概念：h函数（传入的是什么，生成的是什么）、vnode（结构是什么）、patch（干什么，传入的是什么参数）、diff（从patch-patchVnode-addVnodes/removeVnodes-updateChildren）、key（在updateChildren中的重要性）
- vdom存在的价值，数据驱动视图，控制DOM操作





***模板编译***

​    Vue的模板，看着像html，但是并不是真正的html，因为他有指令，差值，JS表达式；所以模板到底是什么？

1.前置知识：JS的with语法

​    with改变{}内自由变量的查找规则，当作obj属性来查找

​    如果找不到匹配的obj属性就会报错

​    with要慎用。它打破了作用域规则，易读性变差

2.vue-template-compiler将模板编译成render函数

​    首先模板不是html这是肯定的，因为html不是一个图灵完备的语言，不能够执行判断循环之类的逻辑，前端只有js是一个图灵完备的语言，所以如果要执行模板中的各种逻辑代码，那么模板一定是以某种方式转为了js代码，由模板转为js代码的过程即编译模板

3.执行render函数生成vnode

​    以属性和动态属性的编译为例，vue拿到我们的模板之后会生成render函数，调用render函数即可得到根据模板生成的vnode，最后通过vnode便可以进行patch和diff

​    模板编译的过程应该在开发环境下就完成，算是优化的一部分

![img](https://img-blog.csdnimg.cn/bef59c55b5b74347833d725c1b70a95e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR54ix5a2m5LmgJiblrabkuaDniLHmiJE=,size_19,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

4.vue组件中可以用render代替template

5.流程就是：模板到——render函数——vnode——再到渲染和更新

***组件 渲染/更新 过程***

​    黄色区域的render函数，说明模板已经编译好了，然后调用render函数生成虚拟dom树，如果render函数中用到了data中的数据，即触发了该数据的getter函数，那么该数据就会被监听。如果对data中数据进行了修改，那么会触发该数据的setter函数，然后会去确认该数据是否正在监听中，如果是那么模板重新编译，重新生成dom树

![img](https://img-blog.csdnimg.cn/54bb18005577450fad464e9c5427c167.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5oiR54ix5a2m5LmgJiblrabkuaDniLHmiJE=,size_16,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

1.初次渲染过程

- 解析模板为render函数（开发环境下完成），这个过程中会收集到在模板中所有用到得数据，收集并监测这些数据
- 执行render函数，生成vnode，pathch（elem，vnode）
- 当上述被监视的数据的setter被调用的时候，就通知观察者去更新视图

2.更新过程

- 修改data，触发setter
- 就通知观察者去更新视图，diff算法

3.异步渲染

- 回顾nextTick：页面是异步渲染的，$nextTick待Dom渲染完成后再执行回调，页面渲染时会将data的修改做一个整合，多次data的修改只会渲染一次，因此nextTick也只会调用一次
- 汇总data的修改，一次性更新视图
- 减少DOM操作次数，提高性能

## 28、Vue-router原理

​    稍微复杂的SPA都需要路由。

**1.vue-router的路由模式**

- hash模式： 
  - hash变化会触发页面跳转，即浏览器的前进后退
  - hash变化不会刷新页面。也是SPA必须的特点
  - hash永远不会提交到server端
  - 主要API，window.onhashchange(event)监听hash的变化，可以通过event获得oldURL和newURL，location.herf修改hash值
- H5 History模式 
  -  用url规范的路由，但是跳转时不刷新页面
  - 会提交到server需要后端的配合，任何路由返回的都是index.html
  - 主要API：history.pushState，window.onpopstate事件监听浏览器的前进和后退
- 总结 
  - hash简单，不需要后端支持

## 29、Vuex原理

1. 首先vuex是一个插件，所以它有一个install方法，当我们通过Vue.use使用这个插件的时候就会自动调用这个install函数

2. 那么在install函数里面做了什么？

   1. 定义一个全局混入Mixin，主要作用就是在每个vue实例身上挂载一个$store，这个stroe就是我们所配置的那个store，而这个挂载的时机放在了beforeCreated里，**那为什么放在beforCreated？**

   2. ```js
      // vuex.js
      let Vue;
      
      // install方法设置，是因为Vue.use(xxx)会执行xxx的install方法
      const install = (v) => { // 参数v负责接收vue实例
          Vue = v;
          // 全局混入
          Vue.mixin({
              beforeCreate() {
                  if (this.$options && this.$options.store) {
                      // 根页面，直接将身上的store赋值给自己的$store，
                      这也解释了为什么使用vuex要先把store放到入口文件main.js里的根Vue实例里
                      this.$store = this.$options.store;
                  } else {
                      // 除了根页面以外，将上级的$store赋值给自己的$store
                      this.$store = this.$parent && this.$parent.$store;
                  }
              },
          })
      }
      ```

3. Vuex里的state为什么可以实现响应式？其实，Vuex.Store构造函数所维护的state是被vue进行了数据代理，我们通过this.$store.state拿到的state其实是this.$store.vm.state，看代码就明白了

   1. ```js
      // 创建类Store
      class Store {
          constructor(options) { // options接收传入的store对象
              this.vm = new Vue({
                  // 确保state是响应式
                  data: {
                      state: options.state
                  }
              });
              //将配置项中的 getter 代理到store实例身上
              let getters = options.getters || {};
              this.getters = {};
              console.log(Object.keys(this.getters))
              Object.keys(getters).forEach(getterName => {
                  Object.defineProperty(this.getters, getterName, {
                      get: () => {
                          return getters[getterName](this.state);
                      }
                  })
              })
              // 将配置项中的 mutation 代理到store实例身上
              let mutations = options.mutations || {};
              this.mutations = {};
              Object.keys(mutations).forEach(mutationName => {
                  this.mutations[mutationName] = payload => {
                      mutations[mutationName](this.state, payload);
                  }
              })
              // 将配置项中的 action 代理到store实例身上
              let actions = options.actions || {};
              this.actions = {};
              Object.keys(actions).forEach(actionName => {
                  this.actions[actionName] = payload => {
                      actions[actionName](this.state, payload);
                  }
              })
          }
          // 定义state的getter，当我们通过this.$store.state获取state的时候返回的是一个被代理的state
          get state() {
              return this.vm.state;
          }
          // commit方法，执行mutations的'name'方法
          commit(name, payload) {
              this.mutations[name](payload);
          }
          // dispatch方法，执行actions的'name'方法
          dispatch(name, payload) {
              this.actions[name](payload);
          }
      }
      ```

## 30、vuex刷新数据丢失解决方案

```
https://blog.csdn.net/guzhao593/article/details/81435342
```

1. 总结就是：页面刷新的时候触发对应回调函数，将vuex的数据存入sessionStorage；当页面加载完毕（created钩子）的时候，通过this.$store.replaceState方法将sessionStorage中存储的数据再放到vuex里
2. 上述代码统一放在App组件进行配置即可

# 五、Vue3

## 1、vue3比vue2好在哪里

1. 性能更好
2. 体积更小
3. 更好的代码组织
4. 更好的逻辑抽离

## 2、defineProperty和proxy的区别

## 3、vue3和vue2生命周期的区别

*OptionsAPI生命周期*

1. beforeDestoryed改为beforeUnmounted
2. destoryed改为unmounted
3. 其他沿用vue2的生命周期

*CompositionAPI生命周期*

1. setup生命周期（代替beforeCreate和created）
2. onBeforeMount
3. onMounted
4. onBeforeUpadte
5. onUpdaed
6. onBeforeUnmount
7. onUnmounted

## 4、Composition API和Options API

*composition API带来了什么*

- 更好的代码组织：分散变为规整

![image-20220307161844093](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307161844093.png)

- 更好的逻辑复用：
- 更好的类型推导：

## 5、如何理解ref toRef和toRefs

*ref*

- 生成值类型的响应式数据
- 可以通过.value修改值

*toRef*

![image-20220307164517196](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307164517196.png)

- 针对响应式对象的一个属性，将其创建成一个ref	
- 此时修改ageRef那么state中的age也会变，同理修改state.age那么ageRef也会变 
- toRef如果用于普通对象，产出的结果不具备响应式
- 总结：一个普通对象如果要变成响应式对象就要用reactive，如果一个响应式对象中的某个属性要单独拿出来做响应式就用toRef

*toRefs*

![image-20220307170926994](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307170926994.png)

- toRefs将一个响应式对象变成一个普通对象，同时将该对象的所有属性都变成ref对象

*toRef和toRefs最佳使用方式*

1. 如果是基本类型：使用ref定义为响应式
2. 如果是引用类型：使用reactive定义为响应式
3. setup中返回的时候，不要直接返回对象，最好使用toRefs或者是toRef包装一下

*为什么要用ref*

1. 如果我们在setup中返回值类型，那么它是不具备响应式的，但是合成函数、计算函数等等又都可能返回值类型。所以需要ref进行包装

*为什么要有.value*

1. ref是一个对象，value存储值，通过.value的set和get实现响应式，ref对象用于模板和reactive不需要.value。其他情况都要
2. .value的存在还是为了保持响应式

*为什么需要toRef和toRefs*

1. 初衷：不丢失响应式的情况下没把对象数据分解/扩散
2. 前提：针对的是响应式对象（reactive）封装的

## 6、Vue3升级了哪些重要的功能

*createApp*

![image-20220307185856859](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307185856859.png)

*emits属性*

![image-20220307190134520](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307190134520.png)

1. 父组件给子组件传递自定义事件的时候，子组件需要声明emits配置项用来接受这个事件的名字，同时emits会默认传递给setup函数

*多事件处理*

![image-20220307190407893](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307190407893.png)

1. 比如说点击一次按钮可以同时触发多个回调函数

*Fragment*

![image-20220307190533968](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307190533968.png)

1. 这个主要针对的是template，以前用vue2的时候，template中只允许有一个根节点，到了vue3这个限制就被取消 了

*异步组件的引入方式不同了*

![image-20220307191024805](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307191024805.png)

*移除filter*

![image-20220307191208899](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307191208899.png)

*Teleport*

![image-20220307191459420](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307191459420.png)

1. 可以把dom结构抽离出去，这样以前的v-if写法就更易读了，点击按钮，下面的dom结构就会被添加到body中去

*Suspend*

1. 作用就是当一个组件没有加载出来的时候，就先展示另外一个默认的组件

*Composition API*

1. ref、reactive
2. toRef、toRefs
3. watch、watchEffect
4. computed

## 7、Composition API实现逻辑复用

1. 抽离逻辑代码到一个函数
2. 函数命名约定为useXxxxx的格式
3. 在setup中去引用useXxxx函数

## 8、Vue3如何实现响应式

- proxy的基本使用

![image-20220307195656692](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307195656692.png)

- reflect

![image-20220307200843009](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307200843009.png)

*proxy如何实现响应式*

```js
        const Obj = {
            name:'张三',
            age:30,

        }
        const proxyObj = new Proxy(Obj,{
            get(target,property,reciver){
                return Reflect.get(target,property)
            } ,
            set(target,property,value){
                console.log('set 方法调用');
            },
            deleteProperty(target,property)
            {
                console.log('我看到你删除属性了');
            }
        })
        console.log(proxyObj.name);
        proxyObj.age=50
        Reflect.deleteProperty(proxyObj,name)
```

1. 基本的响应式通过proxy的配置项来实现
2. 深度的监听就是递归，但是和vue2的深度监听是不一样的，vue2的深度监听是一次性递归到底代理所有的属性，proxy的深度监听是当你访问的时候才去监听       
3. 所以vue3是你获取到哪一层哪一层就实现响应式，是一种惰性的代理 

*总结*

![image-20220307204454912](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307204454912.png)

## 9、Watch和WatchEffect

1. 两者都可以监听属性变化
2. watch需要明确指定监听哪个属性
3. watchEffect会根据其中的属性，自动监听其变化

*watch*

1. watch用来监听基本数据类型的话第一个参数就是变量名，如果是用来监听对象的话第一个参数就要写成回调的形式了

![image-20220307210724033](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307210724033.png)

*watchEffect*

1. 不需要你传入要监视谁，那watchEffect是怎么知道应该去监听谁呢？答案就是你在watchEffect中用了谁他就监听谁，所以说watchEffect一定会执行一次；
2. 因为state.age不在watchEffect的回调中，所以后面修改state.age并不会触发watchEffect的回调

![image-20220307211111012](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220307211111012.png)

## 10、setup中如何获得组件实例

- 在compositionApi中是没有this的，所以无法通过this获取到组件实例
  - 在compositionApi中可以通过getCurrentInstance函数获取当前组件实例
- 在optionsApi中是可以通过this获得组件实例的

## 11、diff优化

*Proxy响应式*

1. 相较于defineProperty的一次性递归监听，Proxy采用的监听策略是只要你用了我我就监听，你不用我我就不监听，按需监听

*patchFlag*

1. patchFlag的优化是在模板编译的时候给动态DOM标记上flag
2. 动态DOM：比如用了v-bind或者v-model或者使用了插值语法，这样编译的时候这个DOM就会被打上标记，表示该节点是动态的，如下面的标记：1，2，8

![image-20220309155108895](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220309155108895.png)

1. diff算法的时候，就只会去比较动态DOM节点而不会去比较静态节点

## 12、模板编译优化

*HoistStatic&&CacheHandler*

1. HoistStatic静态节点提升：如果是一个静态节点，那么这个节点创建的时候将会被缓存下来，下次就直接用了
   1. 多个相邻的静态节点会被合并起来一次创建
   2. 典型的拿空间换事件的优化策略
2. CacheHandler缓存事件
   1. 缓存事件，如果没声明这个事件的回调，那我就声明一次，如果有了那以后就直接用

*SSR和Tree-shaking*

1. tree-shaking：模板编译需要什么就引用什么，相当于是一个动态引入依赖

2. ssr优化：将静态节点直接输出为字符串（html结构）浏览器拿来就可以用，不需要再自己编译，如下方的三个span都已经被编译为html结构的字符串了

   ![image-20220309181352891](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220309181352891.png)

## 13、Vite为什么这么快

1. 开发环境使用ES6 Moudle，无需打包，非常快
   1. 我们用es6实现的模块化，以及互相的依赖关系，可以直接被浏览器解析，而不是像webpack，先将代码打包成es5的代码，这个过程是很慢的，而Vite是不进行打包的，就用es6的语法而不转换为es5的语法格式，所以改动的比较少，速度当然快
2. 生产环境使用rollup，并不会快很多

*ES module在浏览器中的用法*

1.  通过script的type标签，type='moudle'

![image-20220309185054370](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220309185054370.png)

# 六、项目相关&&优化

## 1、首屏加载

1. SPA单页面的加载过程：

   1. 首先是html，也就是FP（First Paint）阶段，代表浏览器第一次向屏幕传输像素点的时间。
   2. 然后是静态资源css、js，之后解析js生成HTML，也就是FCP（First Contentful Paint，首次内容绘制）阶段，css、js资源加载下来了，首次的内容绘制，有一个大结构 了
   3. FP和FCP的区别：前者代表屏幕首次出现像素点的时间，后者代表首次绘制DOM的时间
   4. 最后就是FMP（First Meaningful Paint首次有效绘制，表示页面内容首次出现在屏幕上的时间点，也就是测量用户加载体验的主要指标）：ajax请求数据之后，首次有绘制效果，就是页面加载的差不多了但是可能图片还没加载出来
   5. 总结：从FP 到 FMP这个过程全是白屏，ajax之后才会真正解析我们的数据，把数据放入我们的html标签中

   ![在这里插入图片描述](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e5b1ee452de4fa4a35a19bb038baff5~tplv-k3u1fbpfcp-watermark.awebp)

2. 方案1：预渲染：预渲染就是通过webpack打包的时候渲染，通过无头浏览器（可以把你index.html的内容放入你这个浏览器，但是你这个浏览器是空白的，然后当你进入页面时候直接加载这个index.html，但是没ajax请求），预渲染的使用场景更多是我们所说的静态页面的形式，

3. 方案2：服务端渲染：服务端渲染适用于大型的、页面数据处理较多且较为复杂的、与服务端有数据交互的功能型网站，一个明显的使用场景就是电商网站。

4. 方案3：路由懒加载

## 2、项目为什么需要打包

1. 我 们项目用到的vue文件、less文件、sass文件、es6的模块等等语法浏览器是无法识别的，所以我们要将我们的项目打包成浏览器可以认识的样子，也就是html，因此需要进行打包
2. 打包可以简化我们的代码，对我们的代码进行压缩，去掉开发依赖等

## 3、babel原理

## 4、前后端鉴权

## 5、图片懒加载



```js
// 该回调函数,在图片进入视口和退出视口的时候都会执行一次
// IntersectionObserver函数会往callback中注入一个参数,event,该参数是一个事件数组,
// 包含所有被observe的dom元素的状态:event.target获取dom节点,e.isIntersecting判断是否出现在视口
const callback = function(events){
    console.log('触发');
    events.forEach(event=>{
        if(event.isIntersecting){
            // 获取data-src
            let imgSrc = event.target.getAttribute('data-src')
            event.target.setAttribute('src',imgSrc)
            // 取消观察
            obeserver.unobserve(event.target)
        }   
    })
}
// 创建观察实例,当图片未进入视口的时候会触发一次callback,当图片进入视口的时候又会执行一次
const obeserver = new IntersectionObserver(callback)
// 对每个图片都进行观察
imgs.forEach(img=>{
    obeserver.observe(img)
})
```



## 6、base64编码

1. 将比较小的图片直接以通过编码插入到html中，随着html一起发送到客户端
2. 这样就可以减少一次请求，建立TCP连接的成本比较高
2. 缺点：css代码体积增大，导致解析render树的时间大大增加，增加了首屏空白时间
2. https://blog.csdn.net/WindSunLike/article/details/104549443

# 七、webPack

![image-20220301203414281](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220301203414281.png)

## 1、基本配置

![image-20220310222119782](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220310222119782.png)

1. 拆分配置：webpack打包配置有一个mode选项，默认是development，即开发模式，还有一个模式production模式，也就是生产模式。两个模式下的打包配置是有些不同的，所以我们可以配置项抽取出来分为：通用配置、开发模式配置、生产模式配置
2. 合并配置：比如在生产模式配置中用到了通用配置，那么这两种配置如何合并呢？答案是用到了webpack-merge，通过其中的smart方法，可以实现两个配置对象的合并

![image-20220301170649687](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220301170649687.png)

1. devserver
2. loader
   1. es6：babel-loader
   2. css：style-loader（将css解析结果插入到html的style标签中），css-loader（解析css），postcss-loader（兼容性检查）；（loader列表的执行顺序是从后到前）
   3. less：style-loader，css-loader，less-loader（解析less转为css）

## 2、webpack如何配置多入口

1. 入口名和出口名需要改
   1. 有几个打包页面就要有几个入口
   2. 出口需要通过name变量生成多个出口
2. 针对每一个入口文件都要建立一个Html-Webpack-Pluginc插件
   1. 为了防止一个html页面包含另外一个html页面的chunk，通过chunk属性指定该页面需要哪些chunk，从而避免引入不需要的chunk

## 3、如何抽离CSS

1. 之前配置的loader将css代码也都放在了js中，等解析js的时候再把css样式插入到html中，显然这样是不科学的所以要吧css抽离出来
2. 安装mini-css-extract-plugin
3. louder配置：

![image-20220310223655277](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220310223655277.png)

1. plugin配置：

![image-20220310223740134](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220310223740134.png)

1. optimization配置项：压缩css

![image-20220310223842770](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220310223842770.png)

## 4、module、chunk、bundle的区别

1. module：在webpack的世界里一切都是模块，只要你用了import不管引入的是什么格式的文件，该文件都会被视为一个module
2. chunk：多个module合并而成的一坨代码，chunk活在内存当中
3. bundle：一个chunk一般就对应一个bundle

## 5、babel基本概念

1. 环境搭建
   1. ​	
2. .babelrc配置文件
   1. presets和plugins

## 6、polyfill（补丁）和runtime

- polyfill是干嘛的？

  比如说我们在低版本的浏览器中使用了indexOf方法，但是这个浏览器上不支持indexOf，那么polyfill就会帮我们去定义一个indexOf，也就是你缺啥我给你补个啥，就是打补丁

  1. core-js（polyfill的一个集合），注意core-js无法polyfill在es6中的generator

  1. 所以要用regenerator支持generator

  1. 我们说的bable-polyfill就是core-js和regenerator的集合，Babel 7.4之后已被弃用，建议直接使用core-js和regenerator

- babel-runtime

  1. 背景：polyfill的使用会污染全局环境，为了解决这个问题，就有了babel--runtime


## 7、前端为什么要打包

1. 代码方面：
   1. 体积更小，加载更快
   2. 可以编译高级语言和语法
   3. 兼容性和错误检查
2. 研发流程
   1. 统一高效的开发环境
   2. 统一的构建流程和产出标准
   3. 集成公司构建规范

## 8、babel和webpack的区别

![image-20220310230458140](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220310230458140.png)

## 9、为什么Proxy不能被polyfill

![image-20220310230604372](C:\Users\yannanshan\AppData\Roaming\Typora\typora-user-images\image-20220310230604372.png)

# 八、项目里遇到的难点

## 1、数据结构的合理设计

1. 最近在完成一个简单的需求：大概是需要计算用户的某些指标，但是这些指标依赖的输入和输出各不相同，为了解耦，我单独封装了一个组件，该组件根据父组件传过来的数组进行form表单的渲染，为了完成这个需求我遇到了以下两个问题：
   1. 父组件要如何告诉子组件我需要多少个输入框，以及每个输入框前的label是什么
   2. 如何表明该input输入框的type是哪种。checkBox？text？input？
   3. 如何使用每个指标从而得到对应的输出？
2. 为了解决问题1，我将每个指标的输入label和输入label分别放入一个数组中，再用对象将其包裹，然后通过props传递给子组件
3. 为了解决问题2，我对各个指标所依赖的输入项进行了分析，发现除了性别选项需要用到radio单选框，其他的都可以用文本输入框实现，所以我通过v-for渲染出了文本输入框，随后又单独增加了一个radio框，并根据指标的类型控制是否显示
4. 为了解决问题3，我原本打算直接在组件里写公式，后来发现耦合度太高，然后我就把公式也封装到了一个对象里，并通过id表明该公式属于哪个指标，最终通过一个对象，将组件所需要的所有内容都传递过去了，同时实现了组件的复用
5. 还有一个隐藏的问题，我本打算通过数组收集，但是发现后续改变输入的值并不会触发页面的重新渲染，后面发现了这是vue2响应式的一个缺陷，随后改为vue.set来修改，解决了该问题

## 2、登录状态的验证

1. 这是一个比较常见的需求，首次请求的时候，会将用户名和密码通过post请求发送到服务器，服务器接受到以后会进行校验，如果正确，则返回客户端一个token

```js
    async login({commit},{...userData}){
        let result = await reqUserLogin(userData)
        if(result.code==200)
        {
            commit('LOGIN',result.data.token)
            setToken(result.data.token)
            return 'OK'
        }else
        {
            return Promise.reject(new Error('登录失败'))
        }
    },
```

1. 客户端收到token后将其存到本地储存里，下次发送请求的时候在请求拦截器中对请求头进行相应的设置，在请求头中加入token字段作为用户登录的身份标识

```js
requests.interceptors.request.use((config)=>{
    nProgress.start();
    let userId = store.state.uuid_token;
    if(userId)
        config.headers.userTempId = userId;
    if(registerStore.state.register.userToken)
        config.headers.token=registerStore.state.register.userToken;
    
    return config;
})
```

#  九、Typescript

*js缺陷*

1. 可能存在无法测试出来的bug，很容易埋下安全隐患
2. js维护困难
3. js不适合开发大型项目
4. 面向对象困难
5. js中变量没有类型的概念，属于动态类型
6. js不报错，找不到错误在哪

*什么是TS*

1. js的超集
2. 将js的动态变量转为静态变量
3. 变得类似于java了
4. TS支持变量类型、更好的面向特性



